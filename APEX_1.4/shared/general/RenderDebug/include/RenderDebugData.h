//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright (c) 2009-2018 NVIDIA Corporation. All rights reserved.


#ifndef RENDER_DEBUG_DATA_H
#define RENDER_DEBUG_DATA_H

/*!
\file
\brief debug rendering classes and structures
*/
#include "PxVec2.h"
#include "PxVec3.h"
#include "PxVec4.h"
#include "PxQuat.h"
#include "PxMat33.h"
#include "PxMat44.h"
#include "PsIntrinsics.h"
#include "RenderDebugImpl.h"
#include "RenderDebug.h"
#include <new>

#define MAX_SEND_BUFFER 16384 // send up to 16384 at a time.

namespace RENDER_DEBUG
{

PX_PUSH_PACK_DEFAULT

struct DebugPrimitive;
struct DebugGraphDesc;

//********************************************************************
//********************************************************************


// This enumeration defines the list of graphics primitives that can be generated by the debug renderer.
struct DebugCommand
{
	enum Enum
	{
		SET_CURRENT_RENDER_STATE,	// set the current render state bit flags
		SET_CURRENT_TEXT_SCALE,		// set the floating point scale for 3d text printing.
		SET_CURRENT_COLOR,			// set the current pen color
		SET_CURRENT_ARROW_COLOR,	// set the current arrow (secondary) color
		SET_CURRENT_TEXTURE1,		// set the current texture id
		SET_CURRENT_TEXTURE2,		// set the current texture id
		SET_CURRENT_TILE1,
		SET_CURRENT_TILE2,
		SET_CURRENT_TRANSFORM,		// set the current matrix transform for graphics primitives
		SET_CURRENT_RENDER_SCALE,	// set the current overall render scale.
		SET_CURRENT_ARROW_SIZE,		// set the current size of arrow heads
		SET_CURRENT_USER_ID,		// sets the current user id.
		DEBUG_LINE,					// render a single line segment
		DRAW_GRID,					// render a 3d studio max style grid.
		DEBUG_TEXT,					// display 3d text
		DEBUG_MESSAGE,	// A debug message or a command
		DEBUG_BOUND,				// display a bounding box
		DEBUG_FRUSTUM,				// debug display a view frustum
		DEBUG_POINT,				// highlight a point
		DEBUG_POINT_SCALE,			// Debug a point with different scale on x/y/z
		DEBUG_QUAD,					// Debug a scaled and oriented screen facing quad
		DEBUG_RECT2D,				// display a 2d rectangle
		DEBUG_GRADIENT_LINE,		// draw a line segment with a unique color for each point.
		DEBUG_RAY,					// draw a ray (line with arrow on the end)
		DEBUG_CYLINDER,				// draw a cylinder assuming the default orientation of the PhysX SDK
		DEBUG_POINT_CYLINDER,		// draw a cylinder between two points
		DEBUG_THICK_RAY,			// draw a thick ray, full 3d arrow head.
		DEBUG_PLANE,				// debug visualization of a plane equation (drawn as concentric circles)
		DEBUG_TRI,					// debug visualize a triangle solid/wireframe determined by the current render state.
		DEBUG_TRI_NORMALS,			// debug visualize a triangle using the provided vertex normals
		DEBUG_GRADIENT_TRI,			// debug visualize a solid shaded triangle with unique vertex colors
		DEBUG_GRADIENT_TRI_NORMALS,	// debug visualize a solid shaded triangle with unique vertex normals and vertex colors
		DEBUG_SPHERE,				// debug visualize a coarse sphere
		DEBUG_SQUASHED_SPHERE,		// debug visualize a sphere that has been squashed
		DEBUG_CAPSULE,				// debug visualize a capsule (assumed PhysX SDK orientation) i.e. Y up is 'height'
		DEBUG_AXES,					// debug visualize a set of axes using thick-rays.
		DEBUG_ARC,					// debug visualize an arc.
		DEBUG_THICK_ARC,			// debug visualize a thick arc
		DEBUG_DETAILED_SPHERE,		// debug visualize a highly detailed sphere
		DEBUG_BLOCK_INFO,			// used internally only.
		DEBUG_GRAPH,                // display a graph
		DEBUG_CAPSULE_TAPERED,		// debug visualize a capsule with y-up as height
		DEBUG_CIRCLE,				// debug visualize an oriented circle
		DEBUG_CREATE_TRIANGLE_MESH,	// Create a triangle mesh to render
		DEBUG_RENDER_TRIANGLE_MESH_INSTANCES, // render a sequence of triangle mesh instances
		DEBUG_RELEASE_TRIANGLE_MESH,
		DEBUG_CONE,
		DEBUG_REFRESH_TRIANGLE_MESH_VERTICES,
		DEBUG_TEXT2D,
		DEBUG_CREATE_CUSTOM_TEXTURE,
		DEBUG_RENDER_POINTS,
		DEBUG_RENDER_LINES,
		DEBUG_RENDER_TRIANGLES,
		DEBUG_REGISTER_INPUT_EVENT,
		DEBUG_RESET_INPUT_EVENTS,
		DEBUG_UNREGISTER_INPUT_EVENT,
		DEBUG_SKIP_FRAME,
		DEBUG_CONVEX_HULL,
		DEBUG_LAST
	};
	static PX_INLINE uint32_t getPrimtiveSize(const DebugPrimitive &p); // returns the size of the data associated with a particular primitive type.
};

PX_INLINE void swap4Bytes(void* _data) 
{
	char *data = static_cast<char*>(_data);
	char one_byte;
	one_byte = data[0]; data[0] = data[3]; data[3] = one_byte;
	one_byte = data[1]; data[1] = data[2]; data[2] = one_byte;
}

PX_INLINE void endianSwap(float &v)
{
	swap4Bytes(&v);
}

PX_INLINE void endianSwap(uint32_t &v)
{
	swap4Bytes(&v);
}

PX_INLINE void endianSwap(int32_t &v)
{
	swap4Bytes(&v);
}

PX_INLINE void endianSwap(physx::PxVec2 &v)
{
	swap4Bytes(&v.x);
	swap4Bytes(&v.y);
}

PX_INLINE void endianSwap(physx::PxVec3 &v)
{
	swap4Bytes(&v.x);
	swap4Bytes(&v.y);
	swap4Bytes(&v.z);
}

PX_INLINE void endianSwap(physx::PxVec4 &v)
{
	swap4Bytes(&v.x);
	swap4Bytes(&v.y);
	swap4Bytes(&v.z);
	swap4Bytes(&v.w);
}

PX_INLINE void endianSwap(physx::PxQuat &v)
{
	swap4Bytes(&v.x);
	swap4Bytes(&v.y);
	swap4Bytes(&v.z);
	swap4Bytes(&v.w);
}

PX_INLINE void endianSwap(physx::PxTransform &v)
{
	endianSwap(v.p);
	endianSwap(v.q);
}

PX_INLINE void endianSwap(physx::PxMat33 &v)
{
	uint32_t count = sizeof(v)/4;
	uint32_t *s = reinterpret_cast<uint32_t *>(&v);
	for (uint32_t i=0; i<count; i++)
	{
		swap4Bytes(s);
		s++;
	}
}

PX_INLINE void endianSwap(physx::PxMat44 &v)
{
	uint32_t count = sizeof(v)/4;
	uint32_t *s = reinterpret_cast<uint32_t *>(&v);
	for (uint32_t i=0; i<count; i++)
	{
		swap4Bytes(s);
		s++;
	}
}


// The base class for all debug primitives
struct DebugPrimitive
{
	DebugPrimitive(void) { }
	DebugPrimitive(DebugCommand::Enum c) : mCommand(c)
	{
	}

	void endianFixup(void)
	{
		swap4Bytes(&mCommand);
	}

	uint32_t 	mCommand;
};

// used to transmit render state, current color or other single unsigned int primitives.
struct DebugPrimitiveU32	 : public DebugPrimitive
{
	DebugPrimitiveU32(void) { }
	DebugPrimitiveU32(DebugCommand::Enum cmd,uint32_t v) :
	DebugPrimitive(cmd),
		mValue(v)
	{
	}

	void adjustEndian(void)
	{
		endianSwap(mValue);
	}

	uint32_t mValue;
};

// used to transmit render scale, text scale, or other single float primitives.
struct DebugPrimitiveF32	 : public DebugPrimitive
{
	DebugPrimitiveF32(void) { }
	DebugPrimitiveF32(DebugCommand::Enum cmd,float v) :
	DebugPrimitive(cmd),
		mValue(v)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mValue);
	}

	float mValue;
};
	
// Defines a primitive for a line segment
struct DebugLine : public DebugPrimitive
{
	DebugLine(void) { }
	DebugLine(const physx::PxVec3 &p1,const physx::PxVec3 &p2) :
	DebugPrimitive(DebugCommand::DEBUG_LINE),
		mP1(p1),
		mP2(p2)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
	}

	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
};

// Defines a primitive to draw a grid visualization
struct DrawGrid : public DebugPrimitive
{
	DrawGrid(void) { }
	DrawGrid(bool zup,uint32_t gridSize) :
	DebugPrimitive(DebugCommand::DRAW_GRID),
		mZup(uint32_t(zup)),
		mGridSize(gridSize)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mZup);
		endianSwap(mGridSize);
	}


	uint32_t	mZup;
	uint32_t 	mGridSize;
};

// Defines a primitive to transmit a piece of 3d ASCII text.
#define MAX_DEBUG_MESSAGE_STRING 128
struct DebugMessage : public DebugPrimitive
{
	DebugMessage(void) { }
	DebugMessage(const char *text) : 
	DebugPrimitive(DebugCommand::DEBUG_MESSAGE)
	{
		const char *source = text;
		char *dest = mText;
		char *stop = &mText[MAX_DEBUG_MESSAGE_STRING-1];
		while ( *source && dest < stop )
		{
			*dest++ = *source++;
		}
		*dest = 0;
	}
	void adjustEndian(void)
	{
	}

	char		mText[MAX_DEBUG_MESSAGE_STRING];
};



// Defines a primitive to transmit a piece of 3d ASCII text.
#define MAX_DEBUG_TEXT_STRING 256
struct DebugText : public DebugPrimitive
{
	DebugText(void) { }
	DebugText(const physx::PxVec3 &position,const physx::PxMat44 &pose,const char *text) : 
	DebugPrimitive(DebugCommand::DEBUG_TEXT),
		mPosition(position),
		mPose(pose)
	{
		const char *source = text;
		char *dest = mText;
		char *stop = &mText[MAX_DEBUG_TEXT_STRING-1];
		while ( *source && dest < stop )
		{
			*dest++ = *source++;
		}
		*dest = 0;
	}
	void adjustEndian(void)
	{
		endianSwap(mPosition);
		endianSwap(mPose);
	}

	physx::PxVec3	mPosition; // relative offset from the pose
	physx::PxMat44	mPose;
	char			mText[MAX_DEBUG_TEXT_STRING];
};

struct DebugText2D : public DebugPrimitive
{
	DebugText2D(void) { }
	DebugText2D(const physx::PxVec2 &position,float scale,float shadowOffset,bool forceFixedWidthNumbers,uint32_t textColor,const char *text) : 
	DebugPrimitive(DebugCommand::DEBUG_TEXT2D),
		mPosition(position),
		mScale(scale),
		mShadowOffset(shadowOffset),
		mForceFixWidthNumbers( forceFixedWidthNumbers ? uint32_t(1) : uint32_t(0)),
		mTextColor(textColor)
	{
		const char *source = text;
		char *dest = mText;
		char *stop = &mText[MAX_DEBUG_TEXT_STRING-1];
		while ( *source && dest < stop )
		{
			*dest++ = *source++;
		}
		*dest = 0;
	}

	void adjustEndian(void)
	{
		endianSwap(mPosition);
		endianSwap(mScale);
		endianSwap(mShadowOffset);
		endianSwap(mForceFixWidthNumbers);
		endianSwap(mTextColor);
	}

	physx::PxVec2	mPosition;
	float			mScale;
	float			mShadowOffset;
	uint32_t		mForceFixWidthNumbers;
	uint32_t		mTextColor;
	char			mText[MAX_DEBUG_TEXT_STRING];
};



struct DebugFrustum : public DebugPrimitive
{
	DebugFrustum(void) { }
	DebugFrustum(const physx::PxMat44 &view,const physx::PxMat44 &proj) : 
	DebugPrimitive(DebugCommand::DEBUG_FRUSTUM),mView(view),mProj(proj)
	{

	}
	void adjustEndian(void)
	{
		endianSwap(mView);
		endianSwap(mProj);
	}


	physx::PxMat44	mView;
	physx::PxMat44 mProj;
};

struct DebugCone : public DebugPrimitive
{
	DebugCone(void) { }
	DebugCone(float length,float innerAngle,float outerAngle,uint32_t subDivision,bool closeEnd) : 
	DebugPrimitive(DebugCommand::DEBUG_CONE),mLength(length),mInnerAngle(innerAngle),mOuterAngle(outerAngle),mSubdivision(subDivision),mCloseEnd(uint32_t(closeEnd))
	{

	}
	void adjustEndian(void)
	{
		endianSwap(mLength);
		endianSwap(mInnerAngle);
		endianSwap(mOuterAngle);
		endianSwap(mSubdivision);
		endianSwap(mCloseEnd);
	}


	float			mLength;
	float			mInnerAngle;
	float			mOuterAngle;
	uint32_t		mSubdivision;
	uint32_t		mCloseEnd;
};

struct DebugRegisterInputEvent : public DebugPrimitive
{
	DebugRegisterInputEvent(void) { }
	DebugRegisterInputEvent(bool isDigital,InputEventIds::Enum eventId,float sensitivity,InputIds::Enum inputId) : 
	DebugPrimitive(DebugCommand::DEBUG_REGISTER_INPUT_EVENT),
		mDigital( isDigital ? 1U : 0U),
		mEventId( uint32_t(eventId)),
		mSensitivity( sensitivity),
		mInputId( uint32_t(inputId))
	{

	}
	void adjustEndian(void)
	{
		endianSwap(mDigital);
		endianSwap(mEventId);
		endianSwap(mSensitivity);
		endianSwap(mInputId);
	}

	uint32_t	mDigital;
	uint32_t	mEventId;
	float		mSensitivity;
	uint32_t	mInputId;
};

struct DebugUnregisterInputEvent : public DebugPrimitive
{
	DebugUnregisterInputEvent(void) { }
	DebugUnregisterInputEvent(InputEventIds::Enum eventId) : 
	DebugPrimitive(DebugCommand::DEBUG_UNREGISTER_INPUT_EVENT),
		mEventId( uint32_t( eventId))
	{

	}
	void adjustEndian(void)
	{
		endianSwap(mEventId);
	}

	uint32_t	mEventId;
};

// Defines a primitive to draw a bounding box
struct DebugBound : public DebugPrimitive
{
	DebugBound(void) { }
	DebugBound(const physx::PxVec3 &bmin,const physx::PxVec3 &bmax) : 
	DebugPrimitive(DebugCommand::DEBUG_BOUND),mBmin(bmin),mBmax(bmax)
	{

	}
	void adjustEndian(void)
	{
		endianSwap(mBmin);
		endianSwap(mBmax);
	}

	physx::PxVec3	mBmin;
	physx::PxVec3	mBmax;
};

// Defines a primitive which display a debug point visualization.
struct DebugPoint : public DebugPrimitive
{
	DebugPoint(void) {}
	DebugPoint(const physx::PxVec3 &point,float size) :
	DebugPrimitive(DebugCommand::DEBUG_POINT),
		mPos(point),
		mSize(size)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mPos);
		endianSwap(mSize);
	}


	physx::PxVec3	mPos;
	float			mSize;
};


struct DebugQuad : public DebugPrimitive
{
	DebugQuad(void) {}
	DebugQuad(const physx::PxVec3 &point,const physx::PxVec2 &scale,float rotation) :
	DebugPrimitive(DebugCommand::DEBUG_QUAD),
		mPos(point),
		mScale(scale),
		mRotation(rotation)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mPos);
		endianSwap(mScale);
		endianSwap(mRotation);
	}


	physx::PxVec3	mPos;
	physx::PxVec2	mScale;
	float			mRotation;
};


struct DebugPointScale : public DebugPrimitive
{
	DebugPointScale(void) {}
	DebugPointScale(const physx::PxVec3 &point,physx::PxVec3 size) :
	DebugPrimitive(DebugCommand::DEBUG_POINT_SCALE),
		mPos(point),
		mSize(size)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mPos);
		endianSwap(mSize);
	}


	physx::PxVec3	mPos;
	physx::PxVec3	mSize;
};


// Defines a primitive to display 2d rectangle in screenspace.
struct DebugRect2d : public DebugPrimitive
{
	DebugRect2d(void) { }
	DebugRect2d(float x1,float y1,float x2,float y2) :
	DebugPrimitive(DebugCommand::DEBUG_RECT2D),
		mX1(x1),
		mY1(y1),
		mX2(x2),
		mY2(y2)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mX1);
		endianSwap(mY1);
		endianSwap(mX2);
		endianSwap(mY2);
	}


	float	mX1;
	float	mY1;
	float	mX2;
	float	mY2;
};

// Defines a primitive for a gradient colored line segment
struct DebugGradientLine : public DebugPrimitive
{
	DebugGradientLine(void) { }
	DebugGradientLine(const physx::PxVec3 &p1,const physx::PxVec3 &p2,uint32_t c1,uint32_t c2) :
	DebugPrimitive(DebugCommand::DEBUG_GRADIENT_LINE),
		mP1(p1),
		mP2(p2),
		mC1(c1),
		mC2(c2)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mC1);
		endianSwap(mC2);
	}


	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	uint32_t		mC1;
	uint32_t		mC2;
};

// Defines a primitive to draw a ray indicator (line segment with arrow-head)
struct DebugRay : public DebugPrimitive
{
	DebugRay(void) { }
	DebugRay(const physx::PxVec3 &p1,const physx::PxVec3 &p2) :
	DebugPrimitive(DebugCommand::DEBUG_RAY),
		mP1(p1),
		mP2(p2)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
	}


	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
};

// Defines a primitive to draw a thick ray (solid shaded arrow head)
struct DebugThickRay : public DebugPrimitive
{
	DebugThickRay(void) { }
	DebugThickRay(const physx::PxVec3 &p1,const physx::PxVec3 &p2,float raySize, bool arrowTip) :
	DebugPrimitive(DebugCommand::DEBUG_THICK_RAY),
		mP1(p1),
		mP2(p2),
		mRaySize(raySize),
		mArrowTip(uint32_t(arrowTip))
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
	}


	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	float			mRaySize;
	uint32_t		mArrowTip;
};

// Defines a primitive to visualize a plane equation
struct DebugPlane : public DebugPrimitive
{
	DebugPlane(void) { }
	DebugPlane(const physx::PxVec3 &normal,float dCoff,float radius1,float radius2) :
	DebugPrimitive(DebugCommand::DEBUG_PLANE),
		mNormal(normal),
		mD(dCoff),
		mRadius1(radius1),
		mRadius2(radius2)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mNormal);
		endianSwap(mD);
		endianSwap(mRadius1);
		endianSwap(mRadius2);
	}


	physx::PxVec3	mNormal;
	float			mD;
	float			mRadius1;
	float			mRadius2;
};

// Defines a primitive to visualize a single triangle, either wireframe, or solid, or both based on the current render state bit flags
struct DebugTri : public DebugPrimitive
{
	DebugTri(void) { }
	DebugTri(const physx::PxVec3 &p1,const physx::PxVec3 &p2,const physx::PxVec3 &p3) :
	DebugPrimitive(DebugCommand::DEBUG_TRI),
		mP1(p1),
		mP2(p2),
		mP3(p3)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mP3);
	}


	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	physx::PxVec3	mP3;
};

struct DebugTriNormals : public DebugPrimitive
{
	DebugTriNormals(void) { }
	DebugTriNormals(const physx::PxVec3 &p1,const physx::PxVec3 &p2,const physx::PxVec3 &p3,const physx::PxVec3 &n1,const physx::PxVec3 &n2,const physx::PxVec3 &n3) :
	DebugPrimitive(DebugCommand::DEBUG_TRI_NORMALS),
		mP1(p1),mP2(p2),mP3(p3),
		mN1(n1),mN2(n2),mN3(n3)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mP3);
		endianSwap(mN1);
		endianSwap(mN2);
		endianSwap(mN3);
	}


	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	physx::PxVec3	mP3;
	physx::PxVec3	mN1;
	physx::PxVec3	mN2;
	physx::PxVec3	mN3;
};

struct DebugGradientTri : public DebugPrimitive
{
	DebugGradientTri(void) { }
	DebugGradientTri(const physx::PxVec3 &p1,const physx::PxVec3 &p2,const physx::PxVec3 &p3,const uint32_t &c1,const uint32_t &c2,const uint32_t &c3) :
	DebugPrimitive(DebugCommand::DEBUG_GRADIENT_TRI),
		mP1(p1),mP2(p2),mP3(p3),
		mC1(c1),mC2(c2),mC3(c3)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mP3);
		endianSwap(mC1);
		endianSwap(mC2);
		endianSwap(mC3);
	}

	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	physx::PxVec3	mP3;
	uint32_t		mC1;
	uint32_t		mC2;
	uint32_t		mC3;
};

struct DebugGradientTriNormals : public DebugPrimitive
{
	DebugGradientTriNormals(void) { }
	DebugGradientTriNormals(const physx::PxVec3 &p1,const physx::PxVec3 &p2,const physx::PxVec3 &p3,const physx::PxVec3 &n1,const physx::PxVec3 &n2,const physx::PxVec3 &n3,const uint32_t &c1,const uint32_t &c2,const uint32_t &c3) :
	DebugPrimitive(DebugCommand::DEBUG_GRADIENT_TRI_NORMALS),
		mP1(p1),mP2(p2),mP3(p3),
		mN1(n1),mN2(n2),mN3(n3),
		mC1(c1),mC2(c2),mC3(c3)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mP3);
		endianSwap(mN1);
		endianSwap(mN2);
		endianSwap(mN3);
		endianSwap(mC1);
		endianSwap(mC2);
		endianSwap(mC3);
	}


	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	physx::PxVec3	mP3;
	physx::PxVec3	mN1;
	physx::PxVec3	mN2;
	physx::PxVec3	mN3;
	uint32_t		mC1;
	uint32_t		mC2;
	uint32_t		mC3;
};

struct DebugSphere : public DebugPrimitive
{
	DebugSphere(void) { }
	DebugSphere(float radius, uint32_t subdivision) :
	DebugPrimitive(DebugCommand::DEBUG_SPHERE),
		mRadius(radius),
		mSubdivision(subdivision)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mRadius);
		endianSwap(mSubdivision);
	}


	float		mRadius;
	uint32_t	mSubdivision;
};

struct DebugSquashedSphere : public DebugPrimitive
{
	DebugSquashedSphere(void) { }
	DebugSquashedSphere(const physx::PxVec3 &radius, uint32_t subdivision) :
	DebugPrimitive(DebugCommand::DEBUG_SQUASHED_SPHERE),
		mRadius(radius),
		mSubdivision(subdivision)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mRadius);
		endianSwap(mSubdivision);
	}


	physx::PxVec3	mRadius;
	uint32_t		mSubdivision;
};


struct DebugCapsule : public DebugPrimitive
{
	DebugCapsule(void) { }
	DebugCapsule(float radius,float height,uint32_t subdivision) :
	DebugPrimitive(DebugCommand::DEBUG_CAPSULE),
		mRadius(radius),
		mHeight(height),
		mSubdivision(subdivision)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mRadius);
		endianSwap(mHeight);
		endianSwap(mSubdivision);
	}


	float		mRadius;
	float		mHeight;
	uint32_t	mSubdivision;
};

struct DebugTaperedCapsule : public DebugPrimitive
{
	DebugTaperedCapsule() { }
	DebugTaperedCapsule(float radius1, float radius2, float height, uint32_t subdivision) :
	DebugPrimitive(DebugCommand::DEBUG_CAPSULE_TAPERED),
		mRadius1(radius1),
		mRadius2(radius2),
		mHeight(height),
		mSubdivision(subdivision)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mRadius1);
		endianSwap(mRadius2);
		endianSwap(mHeight);
		endianSwap(mSubdivision);
	}


	float mRadius1;
	float mRadius2;
	float mHeight;
	uint32_t mSubdivision;
};

struct DebugPointCylinder : public DebugPrimitive
{
	DebugPointCylinder(void) { }
	DebugPointCylinder(const physx::PxVec3 &p1,const physx::PxVec3 &p2,float radius) :
	DebugPrimitive(DebugCommand::DEBUG_POINT_CYLINDER),
		mP1(p1),
		mP2(p2),
		mRadius(radius)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mRadius);
	}


	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	float			mRadius;
};


struct DebugCylinder : public DebugPrimitive
{
	DebugCylinder(void) { }
	DebugCylinder(float radius,float height,uint32_t subdivision,bool closeSides) :
	DebugPrimitive(DebugCommand::DEBUG_CYLINDER),
		mRadius1(radius),
		mRadius2(radius),
		mHeight(height),
		mSubdivision(subdivision),
		mCloseSides(uint32_t(closeSides))
	{
	}

	DebugCylinder(float radius1, float radius2, float height, uint32_t subdivision, bool closeSides) :
	DebugPrimitive(DebugCommand::DEBUG_CYLINDER),
		mRadius1(radius1),
		mRadius2(radius2),
		mHeight(height),
		mSubdivision(subdivision),
		mCloseSides(uint32_t(closeSides))
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mRadius1);
		endianSwap(mRadius2);
		endianSwap(mHeight);
		endianSwap(mSubdivision);
		endianSwap(mCloseSides);
	}


	float		mRadius1;
	float		mRadius2;
	float		mHeight;
	uint32_t	mSubdivision;
	uint32_t	mCloseSides;
};

struct DebugCircle : public DebugPrimitive
{
	DebugCircle(void) { }
	DebugCircle(float radius, 
				uint32_t subdivision, 
				bool solid) :
		DebugPrimitive(DebugCommand::DEBUG_CIRCLE),
		mTransform(physx::PxIdentity),
		mRadius(radius),
		mSubdivision(subdivision),
		mDrawSolidCircle(solid)
	{
	}

	void adjustEndian(void)
	{
		endianSwap(mRadius);
		endianSwap(mTransform);
		endianSwap(mSubdivision);
		endianSwap(mDrawSolidCircle);
	}

	physx::PxMat44 mTransform;
	float		   mRadius;
	uint32_t	   mSubdivision;
	int32_t		   mDrawSolidCircle;
};

struct DebugAxes : public DebugPrimitive
{
	DebugAxes(void) { }
	DebugAxes(const physx::PxMat44 &transform,float distance,float brightness,bool showXYZ,bool showRotation, uint32_t axisSwitch, DebugAxesRenderMode::Enum renderMode) :
	DebugPrimitive(DebugCommand::DEBUG_AXES),
		mTransform(transform),
		mDistance(distance),
		mBrightness(brightness),
		mShowXYZ(uint32_t(showXYZ)),
		mShowRotation(uint32_t(showRotation)),
		mAxisSwitch(axisSwitch),
		mRenderMode(renderMode)
	{
	}

	void adjustEndian(void)
	{
		endianSwap(mTransform);
		endianSwap(mDistance);
		endianSwap(mBrightness);
		endianSwap(mShowXYZ);
		endianSwap(mShowRotation);
		endianSwap(mAxisSwitch);
	}


	physx::PxMat44	mTransform;
	float		mDistance;
	float		mBrightness;
	uint32_t	mShowXYZ;
	uint32_t	mShowRotation;
	uint32_t	mAxisSwitch;
	uint32_t	mRenderMode;
};

struct DebugArc : public DebugPrimitive
{
	DebugArc(void) { }
	DebugArc(const physx::PxVec3 &center,const physx::PxVec3 &p1,const physx::PxVec3 &p2,float arrowSize,bool showRoot) :
	DebugPrimitive(DebugCommand::DEBUG_ARC),
		mCenter(center),
		mP1(p1),
		mP2(p2),
		mArrowSize(arrowSize),
		mShowRoot(uint32_t(showRoot))
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mCenter);
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mArrowSize);
		endianSwap(mShowRoot);
	}


	physx::PxVec3	mCenter;
	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	float			mArrowSize;
	uint32_t		mShowRoot;
};

struct DebugThickArc : public DebugPrimitive
{
	DebugThickArc(void) { }
	DebugThickArc(const physx::PxVec3 &center,const physx::PxVec3 &p1,const physx::PxVec3 &p2,float thickness=0.02f,bool showRoot=false) :
	DebugPrimitive(DebugCommand::DEBUG_THICK_ARC),
		mCenter(center),
		mP1(p1),
		mP2(p2),
		mThickness(thickness),
		mShowRoot(uint32_t(showRoot))
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mCenter);
		endianSwap(mP1);
		endianSwap(mP2);
		endianSwap(mThickness);
		endianSwap(mShowRoot);
	}


	physx::PxVec3	mCenter;
	physx::PxVec3	mP1;
	physx::PxVec3	mP2;
	float			mThickness;
	uint32_t		mShowRoot;
};

struct DebugDetailedSphere : public DebugPrimitive
{
	DebugDetailedSphere(void) { }
	DebugDetailedSphere(const physx::PxVec3 &pos,float radius,uint32_t stepCount) :
	DebugPrimitive(DebugCommand::DEBUG_DETAILED_SPHERE),
		mPos(pos),
		mRadius(radius),
		mStepCount(stepCount)
	{
	}

	void adjustEndian(void)
	{
		endianSwap(mPos);
		endianSwap(mRadius);
		endianSwap(mStepCount);
	}


	physx::PxVec3	mPos;
	float			mRadius;
	uint32_t		mStepCount;
};

struct DebugCreateCustomTexture : public DebugPrimitive
{
	DebugCreateCustomTexture(void) { }
	DebugCreateCustomTexture(uint32_t id,const char *textureName) :
	DebugPrimitive(DebugCommand::DEBUG_CREATE_CUSTOM_TEXTURE),
		mId(id)
	{
		const char *source = textureName;
		char *dest = mTextureName;
		char *stop = &mTextureName[MAX_DEBUG_MESSAGE_STRING-1];
		while ( *source && dest < stop )
		{
			*dest++ = *source++;
		}
		*dest = 0;
	}

	void adjustEndian(void)
	{
		endianSwap(mId);
	}


	uint32_t	mId;
	char		mTextureName[MAX_DEBUG_MESSAGE_STRING];
};


struct DebugSetCurrentTransform : public DebugPrimitive
{
	DebugSetCurrentTransform(void) { }
	DebugSetCurrentTransform(const physx::PxMat44 &m) :
	DebugPrimitive(DebugCommand::SET_CURRENT_TRANSFORM),
		mTransform(m)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mTransform);
	}

	physx::PxMat44		mTransform;
};

struct DebugGraphStream : public DebugPrimitive
{
	DebugGraphStream(void) { mAllocated = false; mBuffer = NULL;}
	DebugGraphStream(const DebugGraphDesc &d);
	~DebugGraphStream(void);

	void adjustEndian(void)
	{
		//TODO TODO!
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t mAllocated;
};

struct DebugCreateTriangleMesh : public DebugPrimitive
{
	DebugCreateTriangleMesh(void) { mAllocated = false; mBuffer = NULL;}
	DebugCreateTriangleMesh(uint32_t meshId,
							uint32_t vcount,	// The number of vertices in the triangle mesh
							const RENDER_DEBUG::RenderDebugMeshVertex *meshVertices,	// The array of vertices
							uint32_t tcount,	// The number of triangles (indices must contain tcount*3 values)
							const uint32_t *indices);	// The array of triangle mesh indices

	~DebugCreateTriangleMesh(void);

	void adjustEndian(void)
	{
		uint32_t *s = &mSize;
		swap4Bytes(s);	// The Size.
		s++;
		swap4Bytes(s);
		uint32_t meshId = *s++;
		PX_UNUSED(meshId);
		swap4Bytes(s);
		uint32_t vcount = *s++;
		swap4Bytes(s);
		uint32_t tcount = *s++;
		uint32_t vSwapCount = (sizeof(RenderDebugMeshVertex)/4)*vcount;
		for (uint32_t i=0; i<vSwapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
		uint32_t iSwapCount = tcount*3;
		for (uint32_t i=0; i<iSwapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t mAllocated;
};

struct DebugRenderTriangleMeshInstances : public DebugPrimitive
{
	DebugRenderTriangleMeshInstances(void) { mAllocated = false; mBuffer = NULL;}
	DebugRenderTriangleMeshInstances(uint32_t meshId,
					uint32_t instanceCount,
					const RENDER_DEBUG::RenderDebugInstance *instances);
		

	~DebugRenderTriangleMeshInstances(void);

	void adjustEndian(void)
	{
		uint32_t *s = &mSize;
		swap4Bytes(s);
		s++;
		swap4Bytes(s);
		uint32_t meshId = *s++;
		PX_UNUSED(meshId);
		swap4Bytes(s);
		uint32_t instanceCount = *s++;
		uint32_t swapCount = (sizeof(RenderDebugInstance)/4)*instanceCount;
		for (uint32_t i=0; i<swapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t	 mAllocated;
};

struct DebugConvexHull : public DebugPrimitive
{
	DebugConvexHull(void) { mAllocated = false; mBuffer = NULL;}
	DebugConvexHull(uint32_t planeCount,const float *planes);


	~DebugConvexHull(void);

	void adjustEndian(void)
	{
		uint32_t *s = &mSize;
		swap4Bytes(s);
		s++;
		swap4Bytes(s);	// count
		uint32_t planeCount = *s++;
		uint32_t swapCount = 4*planeCount;
		for (uint32_t i=0; i<swapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t	 mAllocated;
};

struct DebugRenderPoints : public DebugPrimitive
{
	DebugRenderPoints(void) { mAllocated = false; mBuffer = NULL;}
	DebugRenderPoints(uint32_t meshId,
		PointRenderMode mode,
		uint32_t textureId1,
		float textureTile1,
		uint32_t textureId2,
		float textureTile2,
		uint32_t	pointCount,
		const float *points);


	~DebugRenderPoints(void);

	void adjustEndian(void)
	{
		uint32_t *s = &mSize;
		swap4Bytes(s);
		s++;
		swap4Bytes(s);	// meshId
		s++;
		swap4Bytes(s); // mode
		s++;
		swap4Bytes(s); // textureId1
		s++;
		swap4Bytes(s); // textureTile1;
		s++;
		swap4Bytes(s); // textureId2
		s++;
		swap4Bytes(s); // textureTile2;
		s++;
		swap4Bytes(s); // pointCount
		uint32_t pointCount = *s++;
		uint32_t swapCount = 3*pointCount;
		for (uint32_t i=0; i<swapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t	 mAllocated;
};


struct DebugRenderLines : public DebugPrimitive
{
	DebugRenderLines(void) { mAllocated = false; mBuffer = NULL;}
	DebugRenderLines(uint32_t lcount,		
		const RenderDebugVertex *vertices, 
		uint32_t useZ,				
		uint32_t isScreenSpace);


	~DebugRenderLines(void);

	void adjustEndian(void)
	{
		uint32_t *s = &mSize;
		swap4Bytes(s); // size
		s++;
		swap4Bytes(s);	// lcount
		uint32_t lcount = *s++;
		swap4Bytes(s); // useZ
		s++;
		swap4Bytes(s); // isScreenSpace
		s++;
		uint32_t swapCount = (sizeof(RenderDebugVertex)/4)*lcount*2;
		for (uint32_t i=0; i<swapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t	 mAllocated;
};

struct DebugRenderTriangles : public DebugPrimitive
{
	DebugRenderTriangles(void) { mAllocated = false; mBuffer = NULL;}
	DebugRenderTriangles(uint32_t tcount,
		const RenderDebugSolidVertex *vertices,	
		uint32_t useZ,				
		uint32_t isScreenSpace);


	~DebugRenderTriangles(void);

	void adjustEndian(void)
	{
		uint32_t *s = &mSize;
		swap4Bytes(s); //size
		s++;
		swap4Bytes(s);	// tcount
		uint32_t tcount = *s++;
		swap4Bytes(s); // useZ
		s++;
		swap4Bytes(s); // isScreenSpace
		s++;
		uint32_t swapCount = (sizeof(RenderDebugSolidVertex)/4)*tcount*3;
		for (uint32_t i=0; i<swapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t	 mAllocated;
};


struct DebugReleaseTriangleMesh : public DebugPrimitive
{
	DebugReleaseTriangleMesh(void) { }
	DebugReleaseTriangleMesh(uint32_t meshId) :
	DebugPrimitive(DebugCommand::DEBUG_RELEASE_TRIANGLE_MESH),
		mMeshId(meshId)
	{
	}
	void adjustEndian(void)
	{
		endianSwap(mMeshId);
	}

	uint32_t	mMeshId;
};

struct DebugRefreshTriangleMeshVertices : public DebugPrimitive
{
	DebugRefreshTriangleMeshVertices(void) { mAllocated = false; mBuffer = NULL;}
	DebugRefreshTriangleMeshVertices(uint32_t meshID,
		uint32_t vcount,
		const RenderDebugMeshVertex *refreshVertices,
		const uint32_t *refreshIndices);	// The array of triangle mesh indices

	~DebugRefreshTriangleMeshVertices(void);

	void adjustEndian(void)
	{
		uint32_t *s = &mSize;
		swap4Bytes(s);	// The Size.
		s++;
		swap4Bytes(s);
		uint32_t meshId = *s++;
		PX_UNUSED(meshId);
		swap4Bytes(s);
		uint32_t vcount = *s++;
		uint32_t vSwapCount = (sizeof(RenderDebugMeshVertex)/4)*vcount;
		for (uint32_t i=0; i<vSwapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
		uint32_t iSwapCount = vcount;
		for (uint32_t i=0; i<iSwapCount; i++)
		{
			swap4Bytes(s);
			s++;
		}
	}


	uint32_t getSize(void) const { return mSize; }
	uint32_t mSize;
	uint8_t *mBuffer;
private:
	uint32_t mAllocated;
};


PX_COMPILE_TIME_ASSERT(sizeof(DebugPrimitive)==4);
PX_COMPILE_TIME_ASSERT(sizeof(DebugPrimitiveU32)==8);
PX_COMPILE_TIME_ASSERT(sizeof(DebugPrimitiveF32)==8);
PX_COMPILE_TIME_ASSERT(sizeof(DebugLine)==28);
PX_COMPILE_TIME_ASSERT(sizeof(DrawGrid)==12);
PX_COMPILE_TIME_ASSERT(sizeof(DebugMessage)==132);
PX_COMPILE_TIME_ASSERT(sizeof(DebugText)==336);
PX_COMPILE_TIME_ASSERT(sizeof(DebugText2D)==284);
PX_COMPILE_TIME_ASSERT(sizeof(DebugFrustum)==132);
PX_COMPILE_TIME_ASSERT(sizeof(DebugCone)==24);
PX_COMPILE_TIME_ASSERT(sizeof(DebugBound)==28);
PX_COMPILE_TIME_ASSERT(sizeof(DebugPoint)==20);
PX_COMPILE_TIME_ASSERT(sizeof(DebugQuad)==28);
PX_COMPILE_TIME_ASSERT(sizeof(DebugPointScale)==28);
PX_COMPILE_TIME_ASSERT(sizeof(DebugRect2d)==20);
PX_COMPILE_TIME_ASSERT(sizeof(DebugGradientLine)==36);
PX_COMPILE_TIME_ASSERT(sizeof(DebugRay)==28);
PX_COMPILE_TIME_ASSERT(sizeof(DebugThickRay)==36);
PX_COMPILE_TIME_ASSERT(sizeof(DebugPlane)==28);
PX_COMPILE_TIME_ASSERT(sizeof(DebugTri)==40);
PX_COMPILE_TIME_ASSERT(sizeof(DebugTriNormals)==76);
PX_COMPILE_TIME_ASSERT(sizeof(DebugGradientTri)==52);
PX_COMPILE_TIME_ASSERT(sizeof(DebugGradientTriNormals)==88);
PX_COMPILE_TIME_ASSERT(sizeof(DebugSphere)==12);
PX_COMPILE_TIME_ASSERT(sizeof(DebugSquashedSphere)==20);
PX_COMPILE_TIME_ASSERT(sizeof(DebugCapsule)==16);
PX_COMPILE_TIME_ASSERT(sizeof(DebugTaperedCapsule)==20);
PX_COMPILE_TIME_ASSERT(sizeof(DebugPointCylinder)==32);
PX_COMPILE_TIME_ASSERT(sizeof(DebugCylinder)==24);
PX_COMPILE_TIME_ASSERT(sizeof(DebugCircle)==80);
PX_COMPILE_TIME_ASSERT(sizeof(DebugAxes)==92);
PX_COMPILE_TIME_ASSERT(sizeof(DebugArc)==48);
PX_COMPILE_TIME_ASSERT(sizeof(DebugThickArc)==48);
PX_COMPILE_TIME_ASSERT(sizeof(DebugDetailedSphere)==24);
PX_COMPILE_TIME_ASSERT(sizeof(DebugSetCurrentTransform)==68);
#if PX_P64_FAMILY
PX_COMPILE_TIME_ASSERT(sizeof(DebugGraphStream)==24);
PX_COMPILE_TIME_ASSERT(sizeof(DebugCreateTriangleMesh)==24);
PX_COMPILE_TIME_ASSERT(sizeof(DebugRefreshTriangleMeshVertices)==24);
PX_COMPILE_TIME_ASSERT(sizeof(DebugRenderTriangleMeshInstances)==24);
#else
PX_COMPILE_TIME_ASSERT(sizeof(DebugGraphStream)==16);
PX_COMPILE_TIME_ASSERT(sizeof(DebugCreateTriangleMesh)==16);
PX_COMPILE_TIME_ASSERT(sizeof(DebugRefreshTriangleMeshVertices)==16);
PX_COMPILE_TIME_ASSERT(sizeof(DebugRenderTriangleMeshInstances)==16);
#endif

PX_COMPILE_TIME_ASSERT(sizeof(DebugReleaseTriangleMesh)==8);
PX_INLINE void endianSwap(DebugPrimitive *prim)
{
	prim->endianFixup();
	switch ( prim->mCommand )
	{
		case DebugCommand::SET_CURRENT_TRANSFORM:
			{
				DebugSetCurrentTransform *d = static_cast< DebugSetCurrentTransform *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_SKIP_FRAME:
		case DebugCommand::DEBUG_RESET_INPUT_EVENTS:
		case DebugCommand::SET_CURRENT_COLOR:
		case DebugCommand::SET_CURRENT_RENDER_STATE:
		case DebugCommand::SET_CURRENT_ARROW_COLOR:
		case DebugCommand::SET_CURRENT_TEXTURE1:
		case DebugCommand::SET_CURRENT_TEXTURE2:
		case DebugCommand::SET_CURRENT_USER_ID:
			{
				DebugPrimitiveU32 *d = static_cast< DebugPrimitiveU32 *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_BOUND:
			{
				DebugBound *d = static_cast< DebugBound *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::SET_CURRENT_TEXT_SCALE:
		case DebugCommand::SET_CURRENT_RENDER_SCALE:
		case DebugCommand::SET_CURRENT_ARROW_SIZE:
		case DebugCommand::SET_CURRENT_TILE1:
		case DebugCommand::SET_CURRENT_TILE2:
			{
				DebugPrimitiveF32 *d = static_cast< DebugPrimitiveF32 *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_LINE:
			{
				DebugLine *d = static_cast< DebugLine *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DRAW_GRID:
			{
				DrawGrid *d = static_cast< DrawGrid *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_TEXT:
			{
				DebugText *d = static_cast< DebugText *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_TEXT2D:
			{
				DebugText2D *d = static_cast< DebugText2D *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_QUAD:
			{
				DebugQuad *d = static_cast< DebugQuad *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_POINT:
			{
				DebugPoint *d = static_cast< DebugPoint *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_RECT2D:
			{
				DebugRect2d *d = static_cast< DebugRect2d *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_GRADIENT_LINE:
			{
				DebugGradientLine *d = static_cast< DebugGradientLine *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_RAY:
			{
				DebugRay *d = static_cast< DebugRay *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_CYLINDER:
			{
				DebugCylinder *d = static_cast< DebugCylinder *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_CIRCLE:
			{
				DebugCircle *d = static_cast< DebugCircle *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_POINT_CYLINDER:
			{
				DebugPointCylinder *d = static_cast< DebugPointCylinder *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_THICK_RAY:
			{
				DebugThickRay *d = static_cast< DebugThickRay *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_PLANE:
			{
				DebugPlane *d = static_cast< DebugPlane *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_TRI:
			{
				DebugTri *d = static_cast< DebugTri *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_TRI_NORMALS:
			{
				DebugTriNormals *d = static_cast< DebugTriNormals *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_GRADIENT_TRI:
			{
				DebugGradientTri *d = static_cast< DebugGradientTri *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_GRADIENT_TRI_NORMALS:
			{
				DebugGradientTriNormals *d = static_cast< DebugGradientTriNormals *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_SPHERE:
			{
				DebugSphere *d = static_cast< DebugSphere *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_SQUASHED_SPHERE:
			{
				DebugSquashedSphere *d = static_cast< DebugSquashedSphere *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_CAPSULE:
			{
				DebugCapsule *d = static_cast< DebugCapsule *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_AXES:
			{
				DebugAxes *d = static_cast< DebugAxes *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_ARC:
			{
				DebugArc *d = static_cast< DebugArc *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_THICK_ARC:
			{
				DebugThickArc *d = static_cast< DebugThickArc *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_DETAILED_SPHERE:
			{
				DebugDetailedSphere *d = static_cast< DebugDetailedSphere *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_BLOCK_INFO:
			{
				PX_ALWAYS_ASSERT();
			}
			break;
		case DebugCommand::DEBUG_GRAPH:
			{
				DebugGraphStream *d = static_cast< DebugGraphStream *>(prim);
				d->adjustEndian();
				PX_ALWAYS_ASSERT();
			}
			break;
		case DebugCommand::DEBUG_CAPSULE_TAPERED:
			{
				DebugTaperedCapsule *d = static_cast< DebugTaperedCapsule *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_POINT_SCALE:
			{
				DebugPointScale *d = static_cast< DebugPointScale *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_MESSAGE:
			{
				DebugMessage *d = static_cast< DebugMessage *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_CREATE_CUSTOM_TEXTURE:
			{
				DebugCreateCustomTexture *d = static_cast< DebugCreateCustomTexture *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_FRUSTUM:
			{
				DebugFrustum *d = static_cast< DebugFrustum *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_CONE:
			{
				DebugCone *d = static_cast< DebugCone *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_REGISTER_INPUT_EVENT:
			{
				DebugRegisterInputEvent *d = static_cast< DebugRegisterInputEvent *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_UNREGISTER_INPUT_EVENT:
			{
				DebugUnregisterInputEvent *d = static_cast< DebugUnregisterInputEvent *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_CREATE_TRIANGLE_MESH:
			{
				DebugCreateTriangleMesh *d = static_cast< DebugCreateTriangleMesh *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_RENDER_TRIANGLE_MESH_INSTANCES:
			{
				DebugRenderTriangleMeshInstances *d = static_cast< DebugRenderTriangleMeshInstances *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_RENDER_POINTS:
			{
				DebugRenderPoints *d = static_cast< DebugRenderPoints *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_CONVEX_HULL:
			{
				DebugConvexHull *d = static_cast< DebugConvexHull *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_RENDER_LINES:
			{
				DebugRenderLines *d = static_cast< DebugRenderLines *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_RENDER_TRIANGLES:
			{
				DebugRenderTriangles *d = static_cast< DebugRenderTriangles *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_RELEASE_TRIANGLE_MESH:
			{
				DebugReleaseTriangleMesh *d = static_cast< DebugReleaseTriangleMesh *>(prim);
				d->adjustEndian();
			}
			break;
		case DebugCommand::DEBUG_REFRESH_TRIANGLE_MESH_VERTICES:
			{
				DebugRefreshTriangleMeshVertices *d = static_cast< DebugRefreshTriangleMeshVertices *>(prim);
				d->adjustEndian();
			}
			break;
	}
}

//********************************************************************
//********************************************************************

// data structure used to track draw groups.  Used internally only.
struct BlockInfo
{
public:

	BlockInfo(void)
	{
		mHashValue = 0;
		mVisibleState = true;
		mChanged = false;
	}

	uint32_t getHashValue(void) const
	{
		return mHashValue;
	}

	physx::PxMat44		mPose;  // transform for block of data
	uint32_t		mHashValue;
	bool			mVisibleState;
	bool			mChanged; // a semaphore indicating that the state has changed for this block
};



// The current render state data block.
class RenderState
{
public:

	RenderState()
	{
		mStates = 0;
		mColor = 0xcfcfcfcf; // needs to be symmetric to be platform independent.
		mDisplayTime = 0.0001f;
		mArrowColor = 0x5f5f5f5f; // needs to be symmetric to be platform independent.
		mOutlineColor = 0xFFFFFFFF;
		mArrowSize = 0.1f;
		mRenderScale = 1.0f;
		mTextScale = 1.0f;
		mUserId = 0;
		mPose = NULL;
		mBlockInfo = NULL;
		mChangeCount = 0;
		mCurrentPose = physx::PxMat44(physx::PxIdentity);
		mTexture1 = 0;
		mTexture2 = 0;
		mTileRate1 = 1.0f;
		mTileRate2 = 1.0f;
	}

	RenderState(uint32_t s,uint32_t c,float d,uint32_t a,float as,float rs,float ts)
	{
		mStates = s;
		mOutlineColor = 0xFFFFFFFF;
		mColor = c;
		mDisplayTime = d;
		mArrowColor = a;
		mArrowSize = as;
		mRenderScale = rs;
		mTextScale = ts;
		mUserId = 0;
		mPose = NULL;
		mCurrentPose = physx::PxMat44(physx::PxIdentity);
		mBlockInfo = NULL;
		mChangeCount = 0;
		mTexture1 = 0;
		mTexture2 = 0;
		mTileRate1 = 1.0f;
		mTileRate2 = 1.0f;
	}

	PX_INLINE bool isScreen(void) const { return (mStates & RENDER_DEBUG::DebugRenderState::ScreenSpace); }
	PX_INLINE bool isUseZ(void) const { return !(mStates & RENDER_DEBUG::DebugRenderState::NoZbuffer); }
	PX_INLINE bool isSolid(void) const { return (mStates & (RENDER_DEBUG::DebugRenderState::SolidShaded | RENDER_DEBUG::DebugRenderState::SolidWireShaded)) ? true : false; }
	PX_INLINE bool isClockwise(void) const { return !(mStates & RENDER_DEBUG::DebugRenderState::CounterClockwise); }
	PX_INLINE bool isWireframeOverlay(void) const { return (mStates & RENDER_DEBUG::DebugRenderState::SolidWireShaded) ? true : false; }
	PX_INLINE bool isWireframe(void) const
	{
		bool ret = true;
		if ( isSolid() && !isWireframeOverlay() )
		{
			ret = false;
		}
		return ret;
	}

	PX_INLINE  float getDisplayTime(void) const
	{
		return (mStates & RENDER_DEBUG::DebugRenderState::InfiniteLifeSpan) ? PX_MAX_F32 : mDisplayTime;
	}

	PX_INLINE bool isCentered(void) const { return (mStates & RENDER_DEBUG::DebugRenderState::CenterText) ? true : false; }
	PX_INLINE bool isCameraFacing(void) const { return (mStates & RENDER_DEBUG::DebugRenderState::CameraFacing) ? true : false; }
	PX_INLINE bool isCounterClockwise(void) const { return (mStates & RENDER_DEBUG::DebugRenderState::CounterClockwise) ? true : false; }
	PX_INLINE int32_t getUserId(void) const { return mUserId; }

	PX_INLINE void incrementChangeCount(void) { mChangeCount++; }
	PX_INLINE uint32_t getChangeCount(void) const { return mChangeCount; }

	PX_INLINE uint32_t setRenderState(RENDER_DEBUG::DebugRenderState::Enum state)
	{
		mStates|=state;
		return mStates;
	}

	PX_INLINE uint32_t clearRenderState(RENDER_DEBUG::DebugRenderState::Enum state)
	{
		mStates&=~state;
		return mStates;
	}

	PX_INLINE bool hasRenderState(RENDER_DEBUG::DebugRenderState::Enum state) const
	{
		return (state&mStates) ? true : false;
	}

	PX_INLINE void setCurrentColor(uint32_t c1,uint32_t c2)
	{
		mColor = c1;
		mArrowColor = c2;
	}


	uint32_t 		mStates;
	uint32_t 		mColor;
	uint32_t		mTexture1;
	float			mTileRate1;
	uint32_t		mTexture2;
	float			mTileRate2;
	float 			mDisplayTime;
	uint32_t 		mArrowColor;
	uint32_t		mOutlineColor;
	float 			mArrowSize;
	float 			mRenderScale;
	float 			mTextScale;
	uint32_t		mChangeCount;
	int32_t 		 mUserId;
	BlockInfo		*mBlockInfo;
	physx::PxMat44 *mPose;
	physx::PxMat44	 mCurrentPose;
};

struct DebugBlockInfo : public DebugPrimitive
{
	DebugBlockInfo(void) { }
	DebugBlockInfo(BlockInfo *info) :
	DebugPrimitive(DebugCommand::DEBUG_BLOCK_INFO),
		mInfo(info)
	{
		if ( info )
		{
			new ( &mCurrentTransform ) DebugSetCurrentTransform(info->mPose);
		}
	}
	BlockInfo				*mInfo;
	DebugSetCurrentTransform mCurrentTransform; // contains the transform for this block; updated each time it changes.
};

/**
\brief The maximum number of graphs that can be displayed at one time.  (0-5)
*/
#define MAX_GRAPHS 6
/**
\brief The width of the graphs (x axis) when created automatically
*/
#define GRAPH_WIDTH_DEFAULT 0.8f
/**
\brief The height of the graphs (y axis) when created automatically
*/
#define GRAPH_HEIGHT_DEFAULT 0.4f

/**
\brief definition of the debugGraph descriptor used to create graphs
*/
struct DebugGraphDesc 
{
	DebugGraphDesc(void) 
	{ 
		mPoints = NULL;
		mGraphXLabel = NULL;
		mGraphYLabel = NULL;
	}


	/**
	\brief The number of float data points to graph
	*/
	uint32_t	mNumPoints;
	/**
	\brief Pointer to the float data points to graph
	*/
	const float*	mPoints;
	/**
	\brief optional cutoff line drawn horizontally on the graph.  It should be between 0 and mGraphMax.
	0.0f indicates not to draw the cutoff line.
	*/
	float	mCutOffLevel;
	/**
	\brief The maximum value that the graph should be be able to display.
	Noramlly this is slightly larger than the greatest value in the mPoints array to make room for
	future samples that are higher then the current set.
	*/
	float	mGraphMax;
	/**
	\brief The bottom left x coordinate of the graph.
	This is set automatically by the constructor that takes graphNum as an argument.
	NOTE: display coordinates range from -1.0f - + 1.0f
	*/
	float	mGraphXPos;
	/**
	\brief bottom left y coordinate of the graph.
	This is set automatically by the constructor that takes graphNum as an argument.
	NOTE: display coordinates range from -1.0f - + 1.0f
	*/
	float	mGraphYPos;
	/**
	\brief The width of the graph.
	This is set automatically by the constructor that takes graphNum as an argument.
	NOTE: display coordinates range from -1.0f - + 1.0f
	*/
	float	mGraphWidth;
	/**
	\brief The height of the graph.
	This is set automatically by the constructor that takes graphNum as an argument.
	NOTE: display coordinates range from -1.0f - + 1.0f
	*/
	float	mGraphHeight;
	/**
	\brief The color of the data.
	This is set automatically by the constructor that takes graphNum as an argument.
	NOTE: display coordinates range from -1.0f - + 1.0f
	This is set automatically by the constructor that takes graphNum as an argument.
	*/
	uint32_t	mGraphColor;
	/**
	\brief The alternate color of the data if mColorSwitchIndex is set to a value that is a valid
	index to the mPoints array.  The points after mColorSwitchIndex are drawn in this color.
	This is set automatically by the constructor that takes graphNum as an argument.
	*/
	uint32_t	mArrowColor;
	/**
	\brief A pointer to the label for the X axis.
	*/
	const char*	mGraphXLabel;
	/**
	\brief A pointer to the label for the Y axis.
	*/
	const char*	mGraphYLabel;
	/**
	\brief The (optional!) index in the data set at which to switch the color to the color specified by
	mArrorColor.  By default this is set to -1 indicating that no color switch should be performed.
	*/
	uint32_t	mColorSwitchIndex;

};





PX_INLINE uint32_t DebugCommand::getPrimtiveSize(const DebugPrimitive &p)
{
	uint32_t ret=0;

	RENDER_DEBUG::DebugCommand::Enum c = static_cast<RENDER_DEBUG::DebugCommand::Enum>(p.mCommand);
	switch ( c )
	{
		case SET_CURRENT_TRANSFORM:
			ret = sizeof(DebugSetCurrentTransform);
			break;
		case DEBUG_SKIP_FRAME:
		case DEBUG_RESET_INPUT_EVENTS:
		case SET_CURRENT_COLOR:
		case SET_CURRENT_RENDER_STATE:
		case SET_CURRENT_ARROW_COLOR:
		case SET_CURRENT_USER_ID:
		case SET_CURRENT_TEXTURE1:
		case SET_CURRENT_TEXTURE2:
			ret = sizeof(DebugPrimitiveU32);
			break;
		case DEBUG_BOUND:
			ret = sizeof(DebugBound);
			break;
		case SET_CURRENT_TEXT_SCALE:
		case SET_CURRENT_RENDER_SCALE:
		case SET_CURRENT_ARROW_SIZE:
		case SET_CURRENT_TILE1:
		case SET_CURRENT_TILE2:
			ret = sizeof(DebugPrimitiveF32);
			break;
		case DEBUG_LINE:
			ret = sizeof(DebugLine);
			break;
		case DRAW_GRID:
			ret = sizeof(DrawGrid);
			break;
		case DEBUG_TEXT:
			ret = sizeof(DebugText);
			break;
		case DEBUG_TEXT2D:
			ret = sizeof(DebugText2D);
			break;
		case DEBUG_QUAD:
			ret = sizeof(DebugQuad);
			break;
		case DEBUG_POINT:
			ret = sizeof(DebugPoint);
			break;
		case DEBUG_RECT2D:
			ret = sizeof(DebugRect2d);
			break;
		case DEBUG_GRADIENT_LINE:
			ret = sizeof(DebugGradientLine);
			break;
		case DEBUG_RAY:
			ret = sizeof(DebugRay);
			break;
		case DEBUG_CYLINDER:
			ret = sizeof(DebugCylinder);
			break;
		case DEBUG_CIRCLE:
			ret = sizeof(DebugCircle);
			break;
		case DEBUG_POINT_CYLINDER:
			ret = sizeof(DebugPointCylinder);
			break;
		case DEBUG_THICK_RAY:
			ret = sizeof(DebugThickRay);
			break;
		case DEBUG_PLANE:
			ret = sizeof(DebugPlane);
			break;
		case DEBUG_TRI:
			ret = sizeof(DebugTri);
			break;
		case DEBUG_TRI_NORMALS:
			ret = sizeof(DebugTriNormals);
			break;
		case DEBUG_GRADIENT_TRI:
			ret = sizeof(DebugGradientTri);
			break;
		case DEBUG_GRADIENT_TRI_NORMALS:
			ret = sizeof(DebugGradientTriNormals);
			break;
		case DEBUG_SPHERE:
			ret = sizeof(DebugSphere);
			break;
		case DEBUG_SQUASHED_SPHERE:
			ret = sizeof(DebugSquashedSphere);
			break;
		case DEBUG_CAPSULE:
			ret = sizeof(DebugCapsule);
			break;
		case DEBUG_AXES:
			ret = sizeof(DebugAxes);
			break;
		case DEBUG_ARC:
			ret = sizeof(DebugArc);
			break;
		case DEBUG_THICK_ARC:
			ret = sizeof(DebugThickArc);
			break;
		case DEBUG_DETAILED_SPHERE:
			ret = sizeof(DebugDetailedSphere);
			break;
		case DEBUG_BLOCK_INFO:
			ret = sizeof(DebugBlockInfo);
			break;
		case DEBUG_GRAPH:
			{
				const DebugGraphStream *d = static_cast< const DebugGraphStream *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_CAPSULE_TAPERED:
			ret = sizeof(DebugTaperedCapsule);
			break;
		case DEBUG_POINT_SCALE:
			ret = sizeof(DebugPointScale);
			break;
		case DEBUG_MESSAGE:
			ret = sizeof(DebugMessage);
			break;
		case DEBUG_CREATE_CUSTOM_TEXTURE:
			ret = sizeof(DebugCreateCustomTexture);
			break;
		case DEBUG_FRUSTUM:
			ret = sizeof(DebugFrustum);
			break;
		case DEBUG_CONE:
			ret = sizeof(DebugCone);
			break;
		case DEBUG_REGISTER_INPUT_EVENT:
			ret = sizeof(DebugRegisterInputEvent);
			break;
		case DEBUG_UNREGISTER_INPUT_EVENT:
			ret = sizeof(DebugUnregisterInputEvent);
			break;
		case DEBUG_CREATE_TRIANGLE_MESH:
			{
				const DebugCreateTriangleMesh *d = static_cast< const DebugCreateTriangleMesh *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_RENDER_TRIANGLE_MESH_INSTANCES:
			{
				const DebugRenderTriangleMeshInstances *d = static_cast< const DebugRenderTriangleMeshInstances *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_RENDER_POINTS:
			{
				const DebugRenderPoints *d = static_cast< const DebugRenderPoints *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_CONVEX_HULL:
			{
				const DebugConvexHull *d = static_cast< const DebugConvexHull *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_RENDER_LINES:
			{
				const DebugRenderLines *d = static_cast< const DebugRenderLines *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_RENDER_TRIANGLES:
			{
				const DebugRenderTriangles *d = static_cast< const DebugRenderTriangles *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_RELEASE_TRIANGLE_MESH:
			ret = sizeof(DebugReleaseTriangleMesh);
			break;
		case DEBUG_REFRESH_TRIANGLE_MESH_VERTICES:
			{
				const DebugRefreshTriangleMeshVertices *d = static_cast< const DebugRefreshTriangleMeshVertices *>(&p);
				ret = d->getSize();
			}
			break;
		case DEBUG_LAST:
			break;
		default:
			PX_ALWAYS_ASSERT();
			ret = 0;
			break;
	}
	return ret;
}

PX_POP_PACK

} // end of namespace

#endif // RENDER_DEBUG_DATA_H
