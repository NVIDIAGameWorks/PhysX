//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright (c) 2018 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "ApexEmitterActorParameters_0p2.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{

using namespace ApexEmitterActorParameters_0p2NS;

const char* const ApexEmitterActorParameters_0p2Factory::vptr =
    NvParameterized::getVptr<ApexEmitterActorParameters_0p2, ApexEmitterActorParameters_0p2::ClassAlignment>();

const uint32_t NumParamDefs = 8;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 2, 3, 4, 5, 6, 7,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 7 },
	{ TYPE_TRANSFORM, false, (size_t)(&((ParametersStruct*)0)->initialPose), NULL, 0 }, // initialPose
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->initialScale), NULL, 0 }, // initialScale
	{ TYPE_TRANSFORM, false, (size_t)(&((ParametersStruct*)0)->attachRelativePose), NULL, 0 }, // attachRelativePose
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->emitAssetParticles), NULL, 0 }, // emitAssetParticles
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->overlapTestGroupMaskName), NULL, 0 }, // overlapTestGroupMaskName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->overlapTestGroupsMask128Name), NULL, 0 }, // overlapTestGroupsMask128Name
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->emitterDuration), NULL, 0 }, // emitterDuration
};


bool ApexEmitterActorParameters_0p2::mBuiltFlag = false;
NvParameterized::MutexType ApexEmitterActorParameters_0p2::mBuiltFlagMutex;

ApexEmitterActorParameters_0p2::ApexEmitterActorParameters_0p2(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &ApexEmitterActorParameters_0p2FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

ApexEmitterActorParameters_0p2::~ApexEmitterActorParameters_0p2()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void ApexEmitterActorParameters_0p2::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~ApexEmitterActorParameters_0p2();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* ApexEmitterActorParameters_0p2::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* ApexEmitterActorParameters_0p2::getParameterDefinitionTree(void) const
{
	ApexEmitterActorParameters_0p2* tmpParam = const_cast<ApexEmitterActorParameters_0p2*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType ApexEmitterActorParameters_0p2::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType ApexEmitterActorParameters_0p2::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void ApexEmitterActorParameters_0p2::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<ApexEmitterActorParameters_0p2::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void ApexEmitterActorParameters_0p2::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void ApexEmitterActorParameters_0p2::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "This class is used for creating EmitterActor instances", true);
		ParamDefTable[0].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="initialPose"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("initialPose", TYPE_TRANSFORM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The initial pose where the emitter actor will be put into the scene", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="initialScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("initialScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The space scale of the emitter", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="attachRelativePose"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("attachRelativePose", TYPE_TRANSFORM, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The emitter will offset this value from the attach actor pose.", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="emitAssetParticles"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("emitAssetParticles", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "In case this emitter has EmitterGeomExplicit geometry type, it can store a particle list in its asset and also in its actor instance.\nSo if this parameter equals to true, then both particle lists from asset and actor instance will be emitted.\nAnd if this paramater equals to false, then only particle list from actor instance will be emitterd.\n", true);
		HintTable[1].init("shortDescription", "Indicates whether authored asset particle list will be emitted, defaults to true (Used only in case of EmitterGeomExplicit type)", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="overlapTestGroupMaskName"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("overlapTestGroupMaskName", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This name resolves to a 32-bit bitmask of collision groups for overlap tests when particles are \nspawned.  It is resolved by a call to the named resource provider using the 'NSCollisionGroupMask' \nnamespace.  If none is provided, the raycast will hit everything in the scene. \nThis avoids storing fragile enums in asset files.  \n", true);
		HintTable[1].init("shortDescription", "Overlap Test Collision Group Mask Name", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="overlapTestGroupsMask128Name"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("overlapTestGroupsMask128Name", TYPE_STRING, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This name resolves to a 128-bit GroupsMask used for overlap tests when particles are spawned.\nIt is resolved by a call to the named resource provider using the 'NSCollisionGroup128' \n", true);
		HintTable[1].init("shortDescription", "Overlap Test 128-bit Collision Groups Mask", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="emitterDuration"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("emitterDuration", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("min", uint64_t(0), true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("longDescription", "Specifies a duration (in seconds) that the emitter will emit for after being enabled.\nAfter the specified duration, the emitter will turn off, unless it has already been explicitly turned off via an API call.\nThe special value 0.0f means there is no duration, and the emitter will remain on until explicitly turned off.", true);
		HintTable[1].init("min", uint64_t(0), true);
		HintTable[2].init("shortDescription", "Emitter duration time (in seconds)", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(2);
		Children[2] = PDEF_PTR(3);
		Children[3] = PDEF_PTR(4);
		Children[4] = PDEF_PTR(5);
		Children[5] = PDEF_PTR(6);
		Children[6] = PDEF_PTR(7);

		ParamDefTable[0].setChildren(Children, 7);
	}

	mBuiltFlag = true;

}
void ApexEmitterActorParameters_0p2::initStrings(void)
{
	overlapTestGroupMaskName.isAllocated = true;
	overlapTestGroupMaskName.buf = NULL;
	overlapTestGroupsMask128Name.isAllocated = true;
	overlapTestGroupsMask128Name.buf = NULL;
}

void ApexEmitterActorParameters_0p2::initDynamicArrays(void)
{
}

void ApexEmitterActorParameters_0p2::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	initialPose = physx::PxTransform(physx::PxIdentity);
	initialScale = float(1.0);
	attachRelativePose = physx::PxTransform(physx::PxIdentity);
	emitAssetParticles = bool(true);
	emitterDuration = float(PX_MAX_F32);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void ApexEmitterActorParameters_0p2::initReferences(void)
{
}

void ApexEmitterActorParameters_0p2::freeDynamicArrays(void)
{
}

void ApexEmitterActorParameters_0p2::freeStrings(void)
{

	if (overlapTestGroupMaskName.isAllocated && overlapTestGroupMaskName.buf)
	{
		mParameterizedTraits->strfree((char*)overlapTestGroupMaskName.buf);
	}

	if (overlapTestGroupsMask128Name.isAllocated && overlapTestGroupsMask128Name.buf)
	{
		mParameterizedTraits->strfree((char*)overlapTestGroupsMask128Name.buf);
	}
}

void ApexEmitterActorParameters_0p2::freeReferences(void)
{
}

} // namespace parameterized
} // namespace nvidia
