//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright (c) 2018 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "ClothingPhysicalMeshParameters_0p11.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{

using namespace ClothingPhysicalMeshParameters_0p11NS;

const char* const ClothingPhysicalMeshParameters_0p11Factory::vptr =
    NvParameterized::getVptr<ClothingPhysicalMeshParameters_0p11, ClothingPhysicalMeshParameters_0p11::ClassAlignment>();

const uint32_t NumParamDefs = 74;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 35, 43, 52, 53, 54, 62, 71, 72, 73, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 19, 21, 23,
	25, 26, 27, 29, 30, 31, 32, 33, 34, 9, 11, 13, 15, 16, 17, 18, 20, 22, 24, 28, 36,
	37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 55, 56, 57, 58, 59, 60, 61,
	63, 64, 65, 66, 67, 68, 69, 70,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 10 },
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->physicalMesh), CHILDREN(10), 22 }, // physicalMesh
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numVertices), NULL, 0 }, // physicalMesh.numVertices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numSimulatedVertices), NULL, 0 }, // physicalMesh.numSimulatedVertices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numMaxDistance0Vertices), NULL, 0 }, // physicalMesh.numMaxDistance0Vertices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numIndices), NULL, 0 }, // physicalMesh.numIndices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numSimulatedIndices), NULL, 0 }, // physicalMesh.numSimulatedIndices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numBonesPerVertex), NULL, 0 }, // physicalMesh.numBonesPerVertex
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->vertices), CHILDREN(32), 1 }, // physicalMesh.vertices
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.vertices[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->normals), CHILDREN(33), 1 }, // physicalMesh.normals
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.normals[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->skinningNormals), CHILDREN(34), 1 }, // physicalMesh.skinningNormals
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.skinningNormals[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->constrainCoefficients), CHILDREN(35), 1 }, // physicalMesh.constrainCoefficients
	{ TYPE_STRUCT, false, 1 * sizeof(ConstrainCoefficient_Type), CHILDREN(36), 3 }, // physicalMesh.constrainCoefficients[]
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->maxDistance), NULL, 0 }, // physicalMesh.constrainCoefficients[].maxDistance
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->collisionSphereRadius), NULL, 0 }, // physicalMesh.constrainCoefficients[].collisionSphereRadius
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->collisionSphereDistance), NULL, 0 }, // physicalMesh.constrainCoefficients[].collisionSphereDistance
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->boneIndices), CHILDREN(39), 1 }, // physicalMesh.boneIndices
	{ TYPE_U16, false, 1 * sizeof(uint16_t), NULL, 0 }, // physicalMesh.boneIndices[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->boneWeights), CHILDREN(40), 1 }, // physicalMesh.boneWeights
	{ TYPE_F32, false, 1 * sizeof(float), NULL, 0 }, // physicalMesh.boneWeights[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->optimizationData), CHILDREN(41), 1 }, // physicalMesh.optimizationData
	{ TYPE_U8, false, 1 * sizeof(uint8_t), NULL, 0 }, // physicalMesh.optimizationData[]
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->hasNegativeBackstop), NULL, 0 }, // physicalMesh.hasNegativeBackstop
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->isClosed), NULL, 0 }, // physicalMesh.isClosed
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->indices), CHILDREN(42), 1 }, // physicalMesh.indices
	{ TYPE_U32, false, 1 * sizeof(uint32_t), NULL, 0 }, // physicalMesh.indices[]
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->maximumMaxDistance), NULL, 0 }, // physicalMesh.maximumMaxDistance
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->physicalMeshSorting), NULL, 0 }, // physicalMesh.physicalMeshSorting
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->shortestEdgeLength), NULL, 0 }, // physicalMesh.shortestEdgeLength
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->averageEdgeLength), NULL, 0 }, // physicalMesh.averageEdgeLength
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->isTetrahedralMesh), NULL, 0 }, // physicalMesh.isTetrahedralMesh
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->flipNormals), NULL, 0 }, // physicalMesh.flipNormals
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionUpB), CHILDREN(43), 1 }, // transitionUpB
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapB_Type), CHILDREN(44), 6 }, // transitionUpB[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->vtxTetraBary), NULL, 0 }, // transitionUpB[].vtxTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionUpB[].vertexIndexPlusOffset
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->nrmTetraBary), NULL, 0 }, // transitionUpB[].nrmTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->faceIndex0), NULL, 0 }, // transitionUpB[].faceIndex0
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->tetraIndex), NULL, 0 }, // transitionUpB[].tetraIndex
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->submeshIndex), NULL, 0 }, // transitionUpB[].submeshIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionUp), CHILDREN(50), 1 }, // transitionUp
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapD_Type), CHILDREN(51), 7 }, // transitionUp[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexBary), NULL, 0 }, // transitionUp[].vertexBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex0), NULL, 0 }, // transitionUp[].vertexIndex0
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->normalBary), NULL, 0 }, // transitionUp[].normalBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex1), NULL, 0 }, // transitionUp[].vertexIndex1
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->tangentBary), NULL, 0 }, // transitionUp[].tangentBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex2), NULL, 0 }, // transitionUp[].vertexIndex2
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionUp[].vertexIndexPlusOffset
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionUpThickness), NULL, 0 }, // transitionUpThickness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionUpOffset), NULL, 0 }, // transitionUpOffset
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionDownB), CHILDREN(58), 1 }, // transitionDownB
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapB_Type), CHILDREN(59), 6 }, // transitionDownB[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->vtxTetraBary), NULL, 0 }, // transitionDownB[].vtxTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionDownB[].vertexIndexPlusOffset
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->nrmTetraBary), NULL, 0 }, // transitionDownB[].nrmTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->faceIndex0), NULL, 0 }, // transitionDownB[].faceIndex0
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->tetraIndex), NULL, 0 }, // transitionDownB[].tetraIndex
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->submeshIndex), NULL, 0 }, // transitionDownB[].submeshIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionDown), CHILDREN(65), 1 }, // transitionDown
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapD_Type), CHILDREN(66), 7 }, // transitionDown[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexBary), NULL, 0 }, // transitionDown[].vertexBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex0), NULL, 0 }, // transitionDown[].vertexIndex0
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->normalBary), NULL, 0 }, // transitionDown[].normalBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex1), NULL, 0 }, // transitionDown[].vertexIndex1
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapD_Type*)0)->tangentBary), NULL, 0 }, // transitionDown[].tangentBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndex2), NULL, 0 }, // transitionDown[].vertexIndex2
	{ TYPE_U32, false, (size_t)(&((SkinClothMapD_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionDown[].vertexIndexPlusOffset
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionDownThickness), NULL, 0 }, // transitionDownThickness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionDownOffset), NULL, 0 }, // transitionDownOffset
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->referenceCount), NULL, 0 }, // referenceCount
};


bool ClothingPhysicalMeshParameters_0p11::mBuiltFlag = false;
NvParameterized::MutexType ClothingPhysicalMeshParameters_0p11::mBuiltFlagMutex;

ClothingPhysicalMeshParameters_0p11::ClothingPhysicalMeshParameters_0p11(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &ClothingPhysicalMeshParameters_0p11FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

ClothingPhysicalMeshParameters_0p11::~ClothingPhysicalMeshParameters_0p11()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void ClothingPhysicalMeshParameters_0p11::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~ClothingPhysicalMeshParameters_0p11();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* ClothingPhysicalMeshParameters_0p11::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* ClothingPhysicalMeshParameters_0p11::getParameterDefinitionTree(void) const
{
	ClothingPhysicalMeshParameters_0p11* tmpParam = const_cast<ClothingPhysicalMeshParameters_0p11*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType ClothingPhysicalMeshParameters_0p11::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType ClothingPhysicalMeshParameters_0p11::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void ClothingPhysicalMeshParameters_0p11::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<ClothingPhysicalMeshParameters_0p11::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void ClothingPhysicalMeshParameters_0p11::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void ClothingPhysicalMeshParameters_0p11::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="physicalMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("physicalMesh", TYPE_STRUCT, "PhysicalMesh", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The physical mesh data.", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="physicalMesh.numVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("numVertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of vertices of this mesh", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="physicalMesh.numSimulatedVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("numSimulatedVertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of simulated vertices of this mesh", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="physicalMesh.numMaxDistance0Vertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("numMaxDistance0Vertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of vertices that have max distance set to 0", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="physicalMesh.numIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("numIndices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of indices of this mesh", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="physicalMesh.numSimulatedIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("numSimulatedIndices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of simulated indices of this mesh", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="physicalMesh.numBonesPerVertex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("numBonesPerVertex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of bone weights/indices per vertex", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="physicalMesh.vertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("vertices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Array of vertices", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[8].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="physicalMesh.vertices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("vertices", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Array of vertices", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="physicalMesh.normals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("normals", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals provided by the user. The mesh-mesh skinning will try to restore them as good\nas possible throughout simulation. Note, they can differ from the skinningNormals quite drastically.\n", true);
		HintTable[2].init("shortDescription", "Array of normals", true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[10].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="physicalMesh.normals[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("normals", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals provided by the user. The mesh-mesh skinning will try to restore them as good\nas possible throughout simulation. Note, they can differ from the skinningNormals quite drastically.\n", true);
		HintTable[2].init("shortDescription", "Array of normals", true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="physicalMesh.skinningNormals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("skinningNormals", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals of the original mesh. They reflect what should come out of physics but the output\ncan be distorted because parts of the simulation mesh are turned off, resulting in wrong normal computation.\nThey are needed for the flags.CorrectSimulationNormals actorflag.\n", true);
		HintTable[2].init("shortDescription", "Array of skinning normals", true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[12].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="physicalMesh.skinningNormals[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("skinningNormals", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are the normals of the original mesh. They reflect what should come out of physics but the output\ncan be distorted because parts of the simulation mesh are turned off, resulting in wrong normal computation.\nThey are needed for the flags.CorrectSimulationNormals actorflag.\n", true);
		HintTable[2].init("shortDescription", "Array of skinning normals", true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="physicalMesh.constrainCoefficients"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("constrainCoefficients", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are not provided but computed by copying values from the graphical mesh to the physical mesh.\n", true);
		HintTable[2].init("shortDescription", "The clothing constrain coefficients for this mesh.", true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[14].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="physicalMesh.constrainCoefficients[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("constrainCoefficients", TYPE_STRUCT, "ConstrainCoefficient", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are not provided but computed by copying values from the graphical mesh to the physical mesh.\n", true);
		HintTable[2].init("shortDescription", "The clothing constrain coefficients for this mesh.", true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="physicalMesh.constrainCoefficients[].maxDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("maxDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Maximum distance this vertex is allowed to travel from its skinned position.", true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="physicalMesh.constrainCoefficients[].collisionSphereRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("collisionSphereRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Size of the Backstop collision sphere.", true);
		ParamDefTable[17].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="physicalMesh.constrainCoefficients[].collisionSphereDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("collisionSphereDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Distance of the Backstop collision sphere.", true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="physicalMesh.boneIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("boneIndices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone indices per vertex", true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[19].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="physicalMesh.boneIndices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("boneIndices", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone indices per vertex", true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="physicalMesh.boneWeights"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("boneWeights", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone weights per vertex", true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[21].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="physicalMesh.boneWeights[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("boneWeights", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[2].init("shortDescription", "The bone weights per vertex", true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="physicalMesh.optimizationData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("optimizationData", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Each byte contains info for 2 vertices.\nbits 0-3: number of actual bones for that vertex (with boneWeight > 0)\nbit 4: set if that vertex has a negative backstop\nbits 5-7: same data for next vertex\n", true);
		HintTable[2].init("shortDescription", "Per Vertex Number of boneweights > 0, bool if it has negative collision distance", true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[23].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="physicalMesh.optimizationData[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("optimizationData", TYPE_U8, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("longDescription", "Each byte contains info for 2 vertices.\nbits 0-3: number of actual bones for that vertex (with boneWeight > 0)\nbit 4: set if that vertex has a negative backstop\nbits 5-7: same data for next vertex\n", true);
		HintTable[2].init("shortDescription", "Per Vertex Number of boneweights > 0, bool if it has negative collision distance", true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="physicalMesh.hasNegativeBackstop"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("hasNegativeBackstop", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "True if at least 1 has negative collision distance", true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="physicalMesh.isClosed"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("isClosed", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "True if all edges have two adjacent triangles", true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="physicalMesh.indices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("indices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "The index buffer", true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[27].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="physicalMesh.indices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("indices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("NOPVD", uint64_t(1), true);
		HintTable[1].init("shortDescription", "The index buffer", true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="physicalMesh.maximumMaxDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("maximumMaxDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The maximum max-distance value for all the vertices.", true);
		ParamDefTable[29].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="physicalMesh.physicalMeshSorting"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("physicalMeshSorting", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Physical mesh sorting", true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="physicalMesh.shortestEdgeLength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("shortestEdgeLength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Mesh statistic, only needed for debug rendering.", true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="physicalMesh.averageEdgeLength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("averageEdgeLength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Mesh statistic, useful for selecting the thickness of the mesh-mesh skinning.", true);
		ParamDefTable[32].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="physicalMesh.isTetrahedralMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("isTetrahedralMesh", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Are we storing triangles or tetrahedrons in this mesh.", true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="physicalMesh.flipNormals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("flipNormals", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "True when the model has been transformed to left-handed space.", true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="transitionUpB"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("transitionUpB", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[35].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[35].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="transitionUpB[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("transitionUpB", TYPE_STRUCT, "SkinClothMapB", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="transitionUpB[].vtxTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("vtxTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the implicit tetrahedron.", true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="transitionUpB[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="transitionUpB[].nrmTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("nrmTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="transitionUpB[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="transitionUpB[].tetraIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("tetraIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Selects which of the 6 implicit tetrahedrons is used for the mapping.", true);
		ParamDefTable[41].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="transitionUpB[].submeshIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("submeshIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "This is only needed during the authoring stage and thus does not need to be serialized.", true);
		HintTable[2].init("shortDescription", "Index into which Physical Submesh/LoD this element of the mapping belongs to.", true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="transitionUp"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("transitionUp", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[43].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="transitionUp[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("transitionUp", TYPE_STRUCT, "SkinClothMapD", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="transitionUp[].vertexBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("vertexBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the triangle.", true);
		ParamDefTable[45].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="transitionUp[].vertexIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("vertexIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[46].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="transitionUp[].normalBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("normalBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[47].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="transitionUp[].vertexIndex1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("vertexIndex1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="transitionUp[].tangentBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("tangentBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (position+tangent). When position is subtracted this will result in the tangent again.", true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="transitionUp[].vertexIndex2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("vertexIndex2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="transitionUp[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="transitionUpThickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("transitionUpThickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The thickness of the transition map", true);
		ParamDefTable[52].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="transitionUpOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("transitionUpOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The normal offset of the transition map", true);
		ParamDefTable[53].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="transitionDownB"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("transitionDownB", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[54].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[54].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="transitionDownB[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("transitionDownB", TYPE_STRUCT, "SkinClothMapB", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[55].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="transitionDownB[].vtxTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("vtxTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the implicit tetrahedron.", true);
		ParamDefTable[56].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="transitionDownB[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[57].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="transitionDownB[].nrmTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("nrmTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[58].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="transitionDownB[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[59].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="transitionDownB[].tetraIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("tetraIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Selects which of the 6 implicit tetrahedrons is used for the mapping.", true);
		ParamDefTable[60].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=61, longName="transitionDownB[].submeshIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[61];
		ParamDef->init("submeshIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[61].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "This is only needed during the authoring stage and thus does not need to be serialized.", true);
		HintTable[2].init("shortDescription", "Index into which Physical Submesh/LoD this element of the mapping belongs to.", true);
		ParamDefTable[61].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=62, longName="transitionDown"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[62];
		ParamDef->init("transitionDown", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[62].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */



		ParamDefTable[62].setAlignment(16);

		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=63, longName="transitionDown[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[63];
		ParamDef->init("transitionDown", TYPE_STRUCT, "SkinClothMapD", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[63].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=64, longName="transitionDown[].vertexBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[64];
		ParamDef->init("vertexBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the triangle.", true);
		ParamDefTable[64].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=65, longName="transitionDown[].vertexIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[65];
		ParamDef->init("vertexIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[65].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=66, longName="transitionDown[].normalBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[66];
		ParamDef->init("normalBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[66].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=67, longName="transitionDown[].vertexIndex1"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[67];
		ParamDef->init("vertexIndex1", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[67].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=68, longName="transitionDown[].tangentBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[68];
		ParamDef->init("tangentBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (position+tangent). When position is subtracted this will result in the tangent again.", true);
		ParamDefTable[68].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=69, longName="transitionDown[].vertexIndex2"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[69];
		ParamDef->init("vertexIndex2", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Vertex index of the physics triangle.", true);
		ParamDefTable[69].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=70, longName="transitionDown[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[70];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[70].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=71, longName="transitionDownThickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[71];
		ParamDef->init("transitionDownThickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The thickness of the transition map", true);
		ParamDefTable[71].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=72, longName="transitionDownOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[72];
		ParamDef->init("transitionDownOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The normal offset of the transition map", true);
		ParamDefTable[72].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=73, longName="referenceCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[73];
		ParamDef->init("referenceCount", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("READONLY", uint64_t(1), true);
		ParamDefTable[73].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("READONLY", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Only used internally, do not modify", true);
		ParamDefTable[73].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[10];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(35);
		Children[2] = PDEF_PTR(43);
		Children[3] = PDEF_PTR(52);
		Children[4] = PDEF_PTR(53);
		Children[5] = PDEF_PTR(54);
		Children[6] = PDEF_PTR(62);
		Children[7] = PDEF_PTR(71);
		Children[8] = PDEF_PTR(72);
		Children[9] = PDEF_PTR(73);

		ParamDefTable[0].setChildren(Children, 10);
	}

	// SetChildren for: nodeIndex=1, longName="physicalMesh"
	{
		static Definition* Children[22];
		Children[0] = PDEF_PTR(2);
		Children[1] = PDEF_PTR(3);
		Children[2] = PDEF_PTR(4);
		Children[3] = PDEF_PTR(5);
		Children[4] = PDEF_PTR(6);
		Children[5] = PDEF_PTR(7);
		Children[6] = PDEF_PTR(8);
		Children[7] = PDEF_PTR(10);
		Children[8] = PDEF_PTR(12);
		Children[9] = PDEF_PTR(14);
		Children[10] = PDEF_PTR(19);
		Children[11] = PDEF_PTR(21);
		Children[12] = PDEF_PTR(23);
		Children[13] = PDEF_PTR(25);
		Children[14] = PDEF_PTR(26);
		Children[15] = PDEF_PTR(27);
		Children[16] = PDEF_PTR(29);
		Children[17] = PDEF_PTR(30);
		Children[18] = PDEF_PTR(31);
		Children[19] = PDEF_PTR(32);
		Children[20] = PDEF_PTR(33);
		Children[21] = PDEF_PTR(34);

		ParamDefTable[1].setChildren(Children, 22);
	}

	// SetChildren for: nodeIndex=8, longName="physicalMesh.vertices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(9);

		ParamDefTable[8].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=10, longName="physicalMesh.normals"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(11);

		ParamDefTable[10].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=12, longName="physicalMesh.skinningNormals"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(13);

		ParamDefTable[12].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=14, longName="physicalMesh.constrainCoefficients"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(15);

		ParamDefTable[14].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=15, longName="physicalMesh.constrainCoefficients[]"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(16);
		Children[1] = PDEF_PTR(17);
		Children[2] = PDEF_PTR(18);

		ParamDefTable[15].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=19, longName="physicalMesh.boneIndices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(20);

		ParamDefTable[19].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=21, longName="physicalMesh.boneWeights"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(22);

		ParamDefTable[21].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=23, longName="physicalMesh.optimizationData"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(24);

		ParamDefTable[23].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=27, longName="physicalMesh.indices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(28);

		ParamDefTable[27].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=35, longName="transitionUpB"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(36);

		ParamDefTable[35].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=36, longName="transitionUpB[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(37);
		Children[1] = PDEF_PTR(38);
		Children[2] = PDEF_PTR(39);
		Children[3] = PDEF_PTR(40);
		Children[4] = PDEF_PTR(41);
		Children[5] = PDEF_PTR(42);

		ParamDefTable[36].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=43, longName="transitionUp"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(44);

		ParamDefTable[43].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=44, longName="transitionUp[]"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(45);
		Children[1] = PDEF_PTR(46);
		Children[2] = PDEF_PTR(47);
		Children[3] = PDEF_PTR(48);
		Children[4] = PDEF_PTR(49);
		Children[5] = PDEF_PTR(50);
		Children[6] = PDEF_PTR(51);

		ParamDefTable[44].setChildren(Children, 7);
	}

	// SetChildren for: nodeIndex=54, longName="transitionDownB"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(55);

		ParamDefTable[54].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=55, longName="transitionDownB[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(56);
		Children[1] = PDEF_PTR(57);
		Children[2] = PDEF_PTR(58);
		Children[3] = PDEF_PTR(59);
		Children[4] = PDEF_PTR(60);
		Children[5] = PDEF_PTR(61);

		ParamDefTable[55].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=62, longName="transitionDown"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(63);

		ParamDefTable[62].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=63, longName="transitionDown[]"
	{
		static Definition* Children[7];
		Children[0] = PDEF_PTR(64);
		Children[1] = PDEF_PTR(65);
		Children[2] = PDEF_PTR(66);
		Children[3] = PDEF_PTR(67);
		Children[4] = PDEF_PTR(68);
		Children[5] = PDEF_PTR(69);
		Children[6] = PDEF_PTR(70);

		ParamDefTable[63].setChildren(Children, 7);
	}

	mBuiltFlag = true;

}
void ClothingPhysicalMeshParameters_0p11::initStrings(void)
{
}

void ClothingPhysicalMeshParameters_0p11::initDynamicArrays(void)
{
	physicalMesh.vertices.buf = NULL;
	physicalMesh.vertices.isAllocated = true;
	physicalMesh.vertices.elementSize = sizeof(physx::PxVec3);
	physicalMesh.vertices.arraySizes[0] = 0;
	physicalMesh.normals.buf = NULL;
	physicalMesh.normals.isAllocated = true;
	physicalMesh.normals.elementSize = sizeof(physx::PxVec3);
	physicalMesh.normals.arraySizes[0] = 0;
	physicalMesh.skinningNormals.buf = NULL;
	physicalMesh.skinningNormals.isAllocated = true;
	physicalMesh.skinningNormals.elementSize = sizeof(physx::PxVec3);
	physicalMesh.skinningNormals.arraySizes[0] = 0;
	physicalMesh.constrainCoefficients.buf = NULL;
	physicalMesh.constrainCoefficients.isAllocated = true;
	physicalMesh.constrainCoefficients.elementSize = sizeof(ConstrainCoefficient_Type);
	physicalMesh.constrainCoefficients.arraySizes[0] = 0;
	physicalMesh.boneIndices.buf = NULL;
	physicalMesh.boneIndices.isAllocated = true;
	physicalMesh.boneIndices.elementSize = sizeof(uint16_t);
	physicalMesh.boneIndices.arraySizes[0] = 0;
	physicalMesh.boneWeights.buf = NULL;
	physicalMesh.boneWeights.isAllocated = true;
	physicalMesh.boneWeights.elementSize = sizeof(float);
	physicalMesh.boneWeights.arraySizes[0] = 0;
	physicalMesh.optimizationData.buf = NULL;
	physicalMesh.optimizationData.isAllocated = true;
	physicalMesh.optimizationData.elementSize = sizeof(uint8_t);
	physicalMesh.optimizationData.arraySizes[0] = 0;
	physicalMesh.indices.buf = NULL;
	physicalMesh.indices.isAllocated = true;
	physicalMesh.indices.elementSize = sizeof(uint32_t);
	physicalMesh.indices.arraySizes[0] = 0;
	transitionUpB.buf = NULL;
	transitionUpB.isAllocated = true;
	transitionUpB.elementSize = sizeof(SkinClothMapB_Type);
	transitionUpB.arraySizes[0] = 0;
	transitionUp.buf = NULL;
	transitionUp.isAllocated = true;
	transitionUp.elementSize = sizeof(SkinClothMapD_Type);
	transitionUp.arraySizes[0] = 0;
	transitionDownB.buf = NULL;
	transitionDownB.isAllocated = true;
	transitionDownB.elementSize = sizeof(SkinClothMapB_Type);
	transitionDownB.arraySizes[0] = 0;
	transitionDown.buf = NULL;
	transitionDown.isAllocated = true;
	transitionDown.elementSize = sizeof(SkinClothMapD_Type);
	transitionDown.arraySizes[0] = 0;
}

void ClothingPhysicalMeshParameters_0p11::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	physicalMesh.numVertices = uint32_t(0);
	physicalMesh.numSimulatedVertices = uint32_t(0);
	physicalMesh.numIndices = uint32_t(0);
	physicalMesh.numSimulatedIndices = uint32_t(0);
	physicalMesh.numBonesPerVertex = uint32_t(0);
	physicalMesh.hasNegativeBackstop = bool(false);
	physicalMesh.isClosed = bool(false);
	physicalMesh.maximumMaxDistance = float(0);
	physicalMesh.physicalMeshSorting = uint32_t(0);
	physicalMesh.shortestEdgeLength = float(0);
	physicalMesh.averageEdgeLength = float(0);
	physicalMesh.isTetrahedralMesh = bool(false);
	physicalMesh.flipNormals = bool(false);
	transitionUpThickness = float(0);
	transitionUpOffset = float(0);
	transitionDownThickness = float(0);
	transitionDownOffset = float(0);
	referenceCount = uint32_t(0);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void ClothingPhysicalMeshParameters_0p11::initReferences(void)
{
}

void ClothingPhysicalMeshParameters_0p11::freeDynamicArrays(void)
{
	if (physicalMesh.vertices.isAllocated && physicalMesh.vertices.buf)
	{
		mParameterizedTraits->free(physicalMesh.vertices.buf);
	}
	if (physicalMesh.normals.isAllocated && physicalMesh.normals.buf)
	{
		mParameterizedTraits->free(physicalMesh.normals.buf);
	}
	if (physicalMesh.skinningNormals.isAllocated && physicalMesh.skinningNormals.buf)
	{
		mParameterizedTraits->free(physicalMesh.skinningNormals.buf);
	}
	if (physicalMesh.constrainCoefficients.isAllocated && physicalMesh.constrainCoefficients.buf)
	{
		mParameterizedTraits->free(physicalMesh.constrainCoefficients.buf);
	}
	if (physicalMesh.boneIndices.isAllocated && physicalMesh.boneIndices.buf)
	{
		mParameterizedTraits->free(physicalMesh.boneIndices.buf);
	}
	if (physicalMesh.boneWeights.isAllocated && physicalMesh.boneWeights.buf)
	{
		mParameterizedTraits->free(physicalMesh.boneWeights.buf);
	}
	if (physicalMesh.optimizationData.isAllocated && physicalMesh.optimizationData.buf)
	{
		mParameterizedTraits->free(physicalMesh.optimizationData.buf);
	}
	if (physicalMesh.indices.isAllocated && physicalMesh.indices.buf)
	{
		mParameterizedTraits->free(physicalMesh.indices.buf);
	}
	if (transitionUpB.isAllocated && transitionUpB.buf)
	{
		mParameterizedTraits->free(transitionUpB.buf);
	}
	if (transitionUp.isAllocated && transitionUp.buf)
	{
		mParameterizedTraits->free(transitionUp.buf);
	}
	if (transitionDownB.isAllocated && transitionDownB.buf)
	{
		mParameterizedTraits->free(transitionDownB.buf);
	}
	if (transitionDown.isAllocated && transitionDown.buf)
	{
		mParameterizedTraits->free(transitionDown.buf);
	}
}

void ClothingPhysicalMeshParameters_0p11::freeStrings(void)
{
}

void ClothingPhysicalMeshParameters_0p11::freeReferences(void)
{
}

} // namespace parameterized
} // namespace nvidia
