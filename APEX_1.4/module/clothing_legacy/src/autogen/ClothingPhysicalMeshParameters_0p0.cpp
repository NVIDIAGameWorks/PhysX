//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Copyright (c) 2018 NVIDIA Corporation. All rights reserved.

// This file was generated by NvParameterized/scripts/GenParameterized.pl


#include "ClothingPhysicalMeshParameters_0p0.h"
#include <string.h>
#include <stdlib.h>

using namespace NvParameterized;

namespace nvidia
{
namespace parameterized
{

using namespace ClothingPhysicalMeshParameters_0p0NS;

const char* const ClothingPhysicalMeshParameters_0p0Factory::vptr =
    NvParameterized::getVptr<ClothingPhysicalMeshParameters_0p0, ClothingPhysicalMeshParameters_0p0::ClassAlignment>();

const uint32_t NumParamDefs = 76;
static NvParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 28, 34, 36, 37, 43, 51, 57, 58, 59, 67, 73, 74, 75, 2, 3, 4, 5, 7, 9, 11, 13,
	18, 20, 22, 24, 25, 26, 27, 6, 8, 10, 12, 14, 15, 16, 17, 19, 21, 23, 29, 30, 31,
	32, 33, 35, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 52, 53, 54, 55, 56, 60,
	61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72,
};

#define TENUM(type) nvidia::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NvParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 14 },
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->physicalMesh), CHILDREN(14), 15 }, // physicalMesh
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numVertices), NULL, 0 }, // physicalMesh.numVertices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numIndices), NULL, 0 }, // physicalMesh.numIndices
	{ TYPE_U32, false, (size_t)(&((PhysicalMesh_Type*)0)->numBonesPerVertex), NULL, 0 }, // physicalMesh.numBonesPerVertex
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->vertices), CHILDREN(29), 1 }, // physicalMesh.vertices
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.vertices[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->normals), CHILDREN(30), 1 }, // physicalMesh.normals
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.normals[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->skinningNormals), CHILDREN(31), 1 }, // physicalMesh.skinningNormals
	{ TYPE_VEC3, false, 1 * sizeof(physx::PxVec3), NULL, 0 }, // physicalMesh.skinningNormals[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->vertexFlags), CHILDREN(32), 1 }, // physicalMesh.vertexFlags
	{ TYPE_U32, false, 1 * sizeof(uint32_t), NULL, 0 }, // physicalMesh.vertexFlags[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->constrainCoefficients), CHILDREN(33), 1 }, // physicalMesh.constrainCoefficients
	{ TYPE_STRUCT, false, 1 * sizeof(ConstrainCoefficient_Type), CHILDREN(34), 3 }, // physicalMesh.constrainCoefficients[]
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->maxDistance), NULL, 0 }, // physicalMesh.constrainCoefficients[].maxDistance
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->collisionSphereRadius), NULL, 0 }, // physicalMesh.constrainCoefficients[].collisionSphereRadius
	{ TYPE_F32, false, (size_t)(&((ConstrainCoefficient_Type*)0)->collisionSphereDistance), NULL, 0 }, // physicalMesh.constrainCoefficients[].collisionSphereDistance
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->boneIndices), CHILDREN(37), 1 }, // physicalMesh.boneIndices
	{ TYPE_U16, false, 1 * sizeof(uint16_t), NULL, 0 }, // physicalMesh.boneIndices[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->boneWeights), CHILDREN(38), 1 }, // physicalMesh.boneWeights
	{ TYPE_F32, false, 1 * sizeof(float), NULL, 0 }, // physicalMesh.boneWeights[]
	{ TYPE_ARRAY, true, (size_t)(&((PhysicalMesh_Type*)0)->indices), CHILDREN(39), 1 }, // physicalMesh.indices
	{ TYPE_U32, false, 1 * sizeof(uint32_t), NULL, 0 }, // physicalMesh.indices[]
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->maximumMaxDistance), NULL, 0 }, // physicalMesh.maximumMaxDistance
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->shortestEdgeLength), NULL, 0 }, // physicalMesh.shortestEdgeLength
	{ TYPE_F32, false, (size_t)(&((PhysicalMesh_Type*)0)->averageEdgeLength), NULL, 0 }, // physicalMesh.averageEdgeLength
	{ TYPE_BOOL, false, (size_t)(&((PhysicalMesh_Type*)0)->isTetrahedralMesh), NULL, 0 }, // physicalMesh.isTetrahedralMesh
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->submeshes), CHILDREN(40), 1 }, // submeshes
	{ TYPE_STRUCT, false, 1 * sizeof(PhysicalSubmesh_Type), CHILDREN(41), 4 }, // submeshes[]
	{ TYPE_U32, false, (size_t)(&((PhysicalSubmesh_Type*)0)->numIndices), NULL, 0 }, // submeshes[].numIndices
	{ TYPE_U32, false, (size_t)(&((PhysicalSubmesh_Type*)0)->numVertices), NULL, 0 }, // submeshes[].numVertices
	{ TYPE_U32, false, (size_t)(&((PhysicalSubmesh_Type*)0)->cookedDataOffset), NULL, 0 }, // submeshes[].cookedDataOffset
	{ TYPE_U32, false, (size_t)(&((PhysicalSubmesh_Type*)0)->cookedDataLength), NULL, 0 }, // submeshes[].cookedDataLength
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->deformableCookedData), CHILDREN(45), 1 }, // deformableCookedData
	{ TYPE_U8, false, 1 * sizeof(uint8_t), NULL, 0 }, // deformableCookedData[]
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->deformableCookedDataVersion), NULL, 0 }, // deformableCookedDataVersion
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->physicalLods), CHILDREN(46), 1 }, // physicalLods
	{ TYPE_STRUCT, false, 1 * sizeof(PhysicalLod_Type), CHILDREN(47), 4 }, // physicalLods[]
	{ TYPE_U32, false, (size_t)(&((PhysicalLod_Type*)0)->costWithoutIterations), NULL, 0 }, // physicalLods[].costWithoutIterations
	{ TYPE_U32, false, (size_t)(&((PhysicalLod_Type*)0)->submeshId), NULL, 0 }, // physicalLods[].submeshId
	{ TYPE_F32, false, (size_t)(&((PhysicalLod_Type*)0)->solverIterationScale), NULL, 0 }, // physicalLods[].solverIterationScale
	{ TYPE_F32, false, (size_t)(&((PhysicalLod_Type*)0)->maxDistanceReduction), NULL, 0 }, // physicalLods[].maxDistanceReduction
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionUpB), CHILDREN(51), 1 }, // transitionUpB
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapB_Type), CHILDREN(52), 6 }, // transitionUpB[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->vtxTetraBary), NULL, 0 }, // transitionUpB[].vtxTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionUpB[].vertexIndexPlusOffset
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->nrmTetraBary), NULL, 0 }, // transitionUpB[].nrmTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->faceIndex0), NULL, 0 }, // transitionUpB[].faceIndex0
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->tetraIndex), NULL, 0 }, // transitionUpB[].tetraIndex
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->submeshIndex), NULL, 0 }, // transitionUpB[].submeshIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionUpC), CHILDREN(58), 1 }, // transitionUpC
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapC_Type), CHILDREN(59), 4 }, // transitionUpC[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapC_Type*)0)->vertexBary), NULL, 0 }, // transitionUpC[].vertexBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapC_Type*)0)->faceIndex0), NULL, 0 }, // transitionUpC[].faceIndex0
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapC_Type*)0)->normalBary), NULL, 0 }, // transitionUpC[].normalBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapC_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionUpC[].vertexIndexPlusOffset
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionUpThickness), NULL, 0 }, // transitionUpThickness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionUpOffset), NULL, 0 }, // transitionUpOffset
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionDownB), CHILDREN(63), 1 }, // transitionDownB
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapB_Type), CHILDREN(64), 6 }, // transitionDownB[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->vtxTetraBary), NULL, 0 }, // transitionDownB[].vtxTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionDownB[].vertexIndexPlusOffset
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapB_Type*)0)->nrmTetraBary), NULL, 0 }, // transitionDownB[].nrmTetraBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->faceIndex0), NULL, 0 }, // transitionDownB[].faceIndex0
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->tetraIndex), NULL, 0 }, // transitionDownB[].tetraIndex
	{ TYPE_U32, false, (size_t)(&((SkinClothMapB_Type*)0)->submeshIndex), NULL, 0 }, // transitionDownB[].submeshIndex
	{ TYPE_ARRAY, true, (size_t)(&((ParametersStruct*)0)->transitionDownC), CHILDREN(70), 1 }, // transitionDownC
	{ TYPE_STRUCT, false, 1 * sizeof(SkinClothMapC_Type), CHILDREN(71), 4 }, // transitionDownC[]
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapC_Type*)0)->vertexBary), NULL, 0 }, // transitionDownC[].vertexBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapC_Type*)0)->faceIndex0), NULL, 0 }, // transitionDownC[].faceIndex0
	{ TYPE_VEC3, false, (size_t)(&((SkinClothMapC_Type*)0)->normalBary), NULL, 0 }, // transitionDownC[].normalBary
	{ TYPE_U32, false, (size_t)(&((SkinClothMapC_Type*)0)->vertexIndexPlusOffset), NULL, 0 }, // transitionDownC[].vertexIndexPlusOffset
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionDownThickness), NULL, 0 }, // transitionDownThickness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->transitionDownOffset), NULL, 0 }, // transitionDownOffset
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->referenceCount), NULL, 0 }, // referenceCount
};


bool ClothingPhysicalMeshParameters_0p0::mBuiltFlag = false;
NvParameterized::MutexType ClothingPhysicalMeshParameters_0p0::mBuiltFlagMutex;

ClothingPhysicalMeshParameters_0p0::ClothingPhysicalMeshParameters_0p0(NvParameterized::Traits* traits, void* buf, int32_t* refCount) :
	NvParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &ClothingPhysicalMeshParameters_0p0FactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

ClothingPhysicalMeshParameters_0p0::~ClothingPhysicalMeshParameters_0p0()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void ClothingPhysicalMeshParameters_0p0::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NvParameterized::Traits* traits = mParameterizedTraits;
	int32_t* refCount = mRefCount;
	void* buf = mBuffer;

	this->~ClothingPhysicalMeshParameters_0p0();

	NvParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NvParameterized::DefinitionImpl* ClothingPhysicalMeshParameters_0p0::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NvParameterized::DefinitionImpl* ClothingPhysicalMeshParameters_0p0::getParameterDefinitionTree(void) const
{
	ClothingPhysicalMeshParameters_0p0* tmpParam = const_cast<ClothingPhysicalMeshParameters_0p0*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NvParameterized::ErrorType ClothingPhysicalMeshParameters_0p0::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NvParameterized::ErrorType ClothingPhysicalMeshParameters_0p0::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NvParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void ClothingPhysicalMeshParameters_0p0::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<ClothingPhysicalMeshParameters_0p0::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void ClothingPhysicalMeshParameters_0p0::freeParameterDefinitionTable(NvParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NvParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void ClothingPhysicalMeshParameters_0p0::buildTree(void)
{

	uint32_t allocSize = sizeof(NvParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NvParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (uint32_t i = 0; i < NumParamDefs; ++i)
	{
		NV_PARAM_PLACEMENT_NEW(ParamDefTable + i, NvParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="physicalMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("physicalMesh", TYPE_STRUCT, "PhysicalMesh", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The physical mesh data.", true);
		ParamDefTable[1].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="physicalMesh.numVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("numVertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of vertices of this mesh", true);
		ParamDefTable[2].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="physicalMesh.numIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("numIndices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of indices of this mesh", true);
		ParamDefTable[3].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="physicalMesh.numBonesPerVertex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("numBonesPerVertex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Number of bone weights/indices per vertex", true);
		ParamDefTable[4].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="physicalMesh.vertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("vertices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Array of vertices", true);
		ParamDefTable[5].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="physicalMesh.vertices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("vertices", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Array of vertices", true);
		ParamDefTable[6].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="physicalMesh.normals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("normals", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "These are the normals provided by the user. The mesh-mesh skinning will try to restore them as good\nas possible throughout simulation. Note, they can differ from the skinningNormals quite drastically.\n", true);
		HintTable[1].init("shortDescription", "Array of normals", true);
		ParamDefTable[7].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="physicalMesh.normals[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("normals", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "These are the normals provided by the user. The mesh-mesh skinning will try to restore them as good\nas possible throughout simulation. Note, they can differ from the skinningNormals quite drastically.\n", true);
		HintTable[1].init("shortDescription", "Array of normals", true);
		ParamDefTable[8].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="physicalMesh.skinningNormals"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("skinningNormals", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are only needed at authoring time. They reflect what will come out of physics and are thus needed\nto create the mesh-mesh skinning.\n", true);
		HintTable[2].init("shortDescription", "Array of skinning normals", true);
		ParamDefTable[9].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="physicalMesh.skinningNormals[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("skinningNormals", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "These are only needed at authoring time. They reflect what will come out of physics and are thus needed\nto create the mesh-mesh skinning.\n", true);
		HintTable[2].init("shortDescription", "Array of skinning normals", true);
		ParamDefTable[10].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="physicalMesh.vertexFlags"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("vertexFlags", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Specify per vertex flags for the mesh (see NxClothVertexFlags and NxSoftBodyVertexFlags).", true);
		ParamDefTable[11].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="physicalMesh.vertexFlags[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("vertexFlags", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Specify per vertex flags for the mesh (see NxClothVertexFlags and NxSoftBodyVertexFlags).", true);
		ParamDefTable[12].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="physicalMesh.constrainCoefficients"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("constrainCoefficients", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "These are not provided but computed by copying values from the graphical mesh to the physical mesh.\n", true);
		HintTable[1].init("shortDescription", "The clothing constrain coefficients for this mesh.", true);
		ParamDefTable[13].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="physicalMesh.constrainCoefficients[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("constrainCoefficients", TYPE_STRUCT, "ConstrainCoefficient", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "These are not provided but computed by copying values from the graphical mesh to the physical mesh.\n", true);
		HintTable[1].init("shortDescription", "The clothing constrain coefficients for this mesh.", true);
		ParamDefTable[14].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="physicalMesh.constrainCoefficients[].maxDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("maxDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Maximum distance this vertex is allowed to travel from its skinned position.", true);
		ParamDefTable[15].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="physicalMesh.constrainCoefficients[].collisionSphereRadius"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("collisionSphereRadius", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Size of the Backstop collision sphere.", true);
		ParamDefTable[16].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="physicalMesh.constrainCoefficients[].collisionSphereDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("collisionSphereDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Distance of the Backstop collision sphere.", true);
		ParamDefTable[17].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="physicalMesh.boneIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("boneIndices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[1].init("shortDescription", "The bone indices per vertex", true);
		ParamDefTable[18].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="physicalMesh.boneIndices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("boneIndices", TYPE_U16, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[1].init("shortDescription", "The bone indices per vertex", true);
		ParamDefTable[19].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="physicalMesh.boneWeights"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("boneWeights", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[1].init("shortDescription", "The bone weights per vertex", true);
		ParamDefTable[20].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="physicalMesh.boneWeights[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("boneWeights", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "Note: contains numVertices * numBonesPerVertex elements.\n", true);
		HintTable[1].init("shortDescription", "The bone weights per vertex", true);
		ParamDefTable[21].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="physicalMesh.indices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("indices", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The index buffer", true);
		ParamDefTable[22].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="physicalMesh.indices[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("indices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The index buffer", true);
		ParamDefTable[23].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="physicalMesh.maximumMaxDistance"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("maximumMaxDistance", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This is used to deduct how much a physical LoD can reduce the max distance.\n", true);
		HintTable[1].init("shortDescription", "The maximum max-distance value for all the vertices.", true);
		ParamDefTable[24].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="physicalMesh.shortestEdgeLength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("shortestEdgeLength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Mesh statistic, only needed for debug rendering.", true);
		ParamDefTable[25].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="physicalMesh.averageEdgeLength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("averageEdgeLength", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Mesh statistic, useful for selecting the thickness of the mesh-mesh skinning.", true);
		ParamDefTable[26].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="physicalMesh.isTetrahedralMesh"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("isTetrahedralMesh", TYPE_BOOL, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Are we storing triangles or tetrahedrons in this mesh.", true);
		ParamDefTable[27].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="submeshes"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("submeshes", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "A list of submeshes with a varying fraction of the full mesh.", true);
		ParamDefTable[28].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="submeshes[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("submeshes", TYPE_STRUCT, "PhysicalSubmesh", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "A list of submeshes with a varying fraction of the full mesh.", true);
		ParamDefTable[29].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="submeshes[].numIndices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("numIndices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This is only a part of the mesh where all max distances exceed a certain value.\n", true);
		HintTable[1].init("shortDescription", "Size of the index buffer", true);
		ParamDefTable[30].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="submeshes[].numVertices"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("numVertices", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This is only a part of the mesh where all max distances exceed a certain value.\n", true);
		HintTable[1].init("shortDescription", "Size of the vertex buffers", true);
		ParamDefTable[31].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="submeshes[].cookedDataOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("cookedDataOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The cooked data for all Submeshes are collected into one array. This is the offset where to start reading.\n", true);
		HintTable[1].init("shortDescription", "Offset into parent's cooked data array", true);
		ParamDefTable[32].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="submeshes[].cookedDataLength"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("cookedDataLength", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "The cooked data for all Submeshes are collected into one array. This is how much data needs to be read.\n", true);
		HintTable[1].init("shortDescription", "Length of the cooked data", true);
		ParamDefTable[33].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="deformableCookedData"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("deformableCookedData", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "All LoDs cook the data into the same buffer, one after the other.\n", true);
		HintTable[1].init("shortDescription", "The cooked data for all the deformable meshes.", true);
		ParamDefTable[34].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="deformableCookedData[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("deformableCookedData", TYPE_U8, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "All LoDs cook the data into the same buffer, one after the other.\n", true);
		HintTable[1].init("shortDescription", "The cooked data for all the deformable meshes.", true);
		ParamDefTable[35].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=36, longName="deformableCookedDataVersion"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[36];
		ParamDef->init("deformableCookedDataVersion", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "When loading into a different PhysX version, it will cook again on loading.\n", true);
		HintTable[1].init("shortDescription", "The PhysX SDK Version this data was cooked from", true);
		ParamDefTable[36].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=37, longName="physicalLods"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[37];
		ParamDef->init("physicalLods", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The different Physical LoDs", true);
		ParamDefTable[37].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=38, longName="physicalLods[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[38];
		ParamDef->init("physicalLods", TYPE_STRUCT, "PhysicalLod", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The different Physical LoDs", true);
		ParamDefTable[38].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=39, longName="physicalLods[].costWithoutIterations"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[39];
		ParamDef->init("costWithoutIterations", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "costs are numVertices * numSolverIterations. This is numVertices", true);
		ParamDefTable[39].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=40, longName="physicalLods[].submeshId"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[40];
		ParamDef->init("submeshId", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Index of the Submesh that belongs to this LoD.", true);
		ParamDefTable[40].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=41, longName="physicalLods[].solverIterationScale"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[41];
		ParamDef->init("solverIterationScale", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Take only a fraction of the Mesh's solver iterations for this LoD.", true);
		ParamDefTable[41].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=42, longName="physicalLods[].maxDistanceReduction"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[42];
		ParamDef->init("maxDistanceReduction", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The amount of maxDistance that gets subtracted when this LoD is active.", true);
		ParamDefTable[42].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=43, longName="transitionUpB"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[43];
		ParamDef->init("transitionUpB", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[43].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=44, longName="transitionUpB[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[44];
		ParamDef->init("transitionUpB", TYPE_STRUCT, "SkinClothMapB", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[44].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=45, longName="transitionUpB[].vtxTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[45];
		ParamDef->init("vtxTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the implicit tetrahedron.", true);
		ParamDefTable[45].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=46, longName="transitionUpB[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[46];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[46].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=47, longName="transitionUpB[].nrmTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[47];
		ParamDef->init("nrmTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[47].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=48, longName="transitionUpB[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[48];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[48].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=49, longName="transitionUpB[].tetraIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[49];
		ParamDef->init("tetraIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Selects which of the 6 implicit tetrahedrons is used for the mapping.", true);
		ParamDefTable[49].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=50, longName="transitionUpB[].submeshIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[50];
		ParamDef->init("submeshIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "This is only needed during the authoring stage and thus does not need to be serialized.\n", true);
		HintTable[2].init("shortDescription", "Index into which Physical Submesh/LoD this element of the mapping belongs to.", true);
		ParamDefTable[50].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=51, longName="transitionUpC"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[51];
		ParamDef->init("transitionUpC", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[51].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=52, longName="transitionUpC[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[52];
		ParamDef->init("transitionUpC", TYPE_STRUCT, "SkinClothMapC", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the next graphical LoD.", true);
		ParamDefTable[52].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=53, longName="transitionUpC[].vertexBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[53];
		ParamDef->init("vertexBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the triangle.", true);
		ParamDefTable[53].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=54, longName="transitionUpC[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[54];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[54].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=55, longName="transitionUpC[].normalBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[55];
		ParamDef->init("normalBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[55].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=56, longName="transitionUpC[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[56];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[56].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=57, longName="transitionUpThickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[57];
		ParamDef->init("transitionUpThickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The thickness of the transition map", true);
		ParamDefTable[57].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=58, longName="transitionUpOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[58];
		ParamDef->init("transitionUpOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The normal offset of the transition map", true);
		ParamDefTable[58].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=59, longName="transitionDownB"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[59];
		ParamDef->init("transitionDownB", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[59].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=60, longName="transitionDownB[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[60];
		ParamDef->init("transitionDownB", TYPE_STRUCT, "SkinClothMapB", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[60].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=61, longName="transitionDownB[].vtxTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[61];
		ParamDef->init("vtxTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the implicit tetrahedron.", true);
		ParamDefTable[61].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=62, longName="transitionDownB[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[62];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[62].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=63, longName="transitionDownB[].nrmTetraBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[63];
		ParamDef->init("nrmTetraBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[63].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=64, longName="transitionDownB[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[64];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[64].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=65, longName="transitionDownB[].tetraIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[65];
		ParamDef->init("tetraIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Selects which of the 6 implicit tetrahedrons is used for the mapping.", true);
		ParamDefTable[65].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=66, longName="transitionDownB[].submeshIndex"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[66];
		ParamDef->init("submeshIndex", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		ParamDefTable[66].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("DONOTSERIALIZE", uint64_t(1), true);
		HintTable[1].init("longDescription", "This is only needed during the authoring stage and thus does not need to be serialized.\n", true);
		HintTable[2].init("shortDescription", "Index into which Physical Submesh/LoD this element of the mapping belongs to.", true);
		ParamDefTable[66].setHints((const NvParameterized::Hint**)HintPtrTable, 3);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=67, longName="transitionDownC"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[67];
		ParamDef->init("transitionDownC", TYPE_ARRAY, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[67].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */




		ParamDef->setArraySize(-1);
	}

	// Initialize DefinitionImpl node: nodeIndex=68, longName="transitionDownC[]"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[68];
		ParamDef->init("transitionDownC", TYPE_STRUCT, "SkinClothMapC", true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Transition between this and the previous graphical LoD.", true);
		ParamDefTable[68].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=69, longName="transitionDownC[].vertexBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[69];
		ParamDef->init("vertexBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate into the triangle.", true);
		ParamDefTable[69].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=70, longName="transitionDownC[].faceIndex0"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[70];
		ParamDef->init("faceIndex0", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "First index of the 3 consecutive indices making the physical triangle.", true);
		ParamDefTable[70].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=71, longName="transitionDownC[].normalBary"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[71];
		ParamDef->init("normalBary", TYPE_VEC3, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The barycentric coordinate of (vertex+normal). When vertex is subtracted this will result in the normal again.", true);
		ParamDefTable[71].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=72, longName="transitionDownC[].vertexIndexPlusOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[72];
		ParamDef->init("vertexIndexPlusOffset", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The vertex index in the graphical mesh (the target index).", true);
		ParamDefTable[72].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=73, longName="transitionDownThickness"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[73];
		ParamDef->init("transitionDownThickness", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The thickness of the transition map", true);
		ParamDefTable[73].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=74, longName="transitionDownOffset"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[74];
		ParamDef->init("transitionDownOffset", TYPE_F32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "The normal offset of the transition map", true);
		ParamDefTable[74].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=75, longName="referenceCount"
	{
		NvParameterized::DefinitionImpl* ParamDef = &ParamDefTable[75];
		ParamDef->init("referenceCount", TYPE_U32, NULL, true);

#ifdef NV_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("READONLY", uint64_t(1), true);
		ParamDefTable[75].setHints((const NvParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("READONLY", uint64_t(1), true);
		HintTable[1].init("shortDescription", "Only used internally, do not modify", true);
		ParamDefTable[75].setHints((const NvParameterized::Hint**)HintPtrTable, 2);

#endif /* NV_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[14];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(28);
		Children[2] = PDEF_PTR(34);
		Children[3] = PDEF_PTR(36);
		Children[4] = PDEF_PTR(37);
		Children[5] = PDEF_PTR(43);
		Children[6] = PDEF_PTR(51);
		Children[7] = PDEF_PTR(57);
		Children[8] = PDEF_PTR(58);
		Children[9] = PDEF_PTR(59);
		Children[10] = PDEF_PTR(67);
		Children[11] = PDEF_PTR(73);
		Children[12] = PDEF_PTR(74);
		Children[13] = PDEF_PTR(75);

		ParamDefTable[0].setChildren(Children, 14);
	}

	// SetChildren for: nodeIndex=1, longName="physicalMesh"
	{
		static Definition* Children[15];
		Children[0] = PDEF_PTR(2);
		Children[1] = PDEF_PTR(3);
		Children[2] = PDEF_PTR(4);
		Children[3] = PDEF_PTR(5);
		Children[4] = PDEF_PTR(7);
		Children[5] = PDEF_PTR(9);
		Children[6] = PDEF_PTR(11);
		Children[7] = PDEF_PTR(13);
		Children[8] = PDEF_PTR(18);
		Children[9] = PDEF_PTR(20);
		Children[10] = PDEF_PTR(22);
		Children[11] = PDEF_PTR(24);
		Children[12] = PDEF_PTR(25);
		Children[13] = PDEF_PTR(26);
		Children[14] = PDEF_PTR(27);

		ParamDefTable[1].setChildren(Children, 15);
	}

	// SetChildren for: nodeIndex=5, longName="physicalMesh.vertices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(6);

		ParamDefTable[5].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=7, longName="physicalMesh.normals"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(8);

		ParamDefTable[7].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=9, longName="physicalMesh.skinningNormals"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(10);

		ParamDefTable[9].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=11, longName="physicalMesh.vertexFlags"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(12);

		ParamDefTable[11].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=13, longName="physicalMesh.constrainCoefficients"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(14);

		ParamDefTable[13].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=14, longName="physicalMesh.constrainCoefficients[]"
	{
		static Definition* Children[3];
		Children[0] = PDEF_PTR(15);
		Children[1] = PDEF_PTR(16);
		Children[2] = PDEF_PTR(17);

		ParamDefTable[14].setChildren(Children, 3);
	}

	// SetChildren for: nodeIndex=18, longName="physicalMesh.boneIndices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(19);

		ParamDefTable[18].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=20, longName="physicalMesh.boneWeights"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(21);

		ParamDefTable[20].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=22, longName="physicalMesh.indices"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(23);

		ParamDefTable[22].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=28, longName="submeshes"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(29);

		ParamDefTable[28].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=29, longName="submeshes[]"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(30);
		Children[1] = PDEF_PTR(31);
		Children[2] = PDEF_PTR(32);
		Children[3] = PDEF_PTR(33);

		ParamDefTable[29].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=34, longName="deformableCookedData"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(35);

		ParamDefTable[34].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=37, longName="physicalLods"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(38);

		ParamDefTable[37].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=38, longName="physicalLods[]"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(39);
		Children[1] = PDEF_PTR(40);
		Children[2] = PDEF_PTR(41);
		Children[3] = PDEF_PTR(42);

		ParamDefTable[38].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=43, longName="transitionUpB"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(44);

		ParamDefTable[43].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=44, longName="transitionUpB[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(45);
		Children[1] = PDEF_PTR(46);
		Children[2] = PDEF_PTR(47);
		Children[3] = PDEF_PTR(48);
		Children[4] = PDEF_PTR(49);
		Children[5] = PDEF_PTR(50);

		ParamDefTable[44].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=51, longName="transitionUpC"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(52);

		ParamDefTable[51].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=52, longName="transitionUpC[]"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(53);
		Children[1] = PDEF_PTR(54);
		Children[2] = PDEF_PTR(55);
		Children[3] = PDEF_PTR(56);

		ParamDefTable[52].setChildren(Children, 4);
	}

	// SetChildren for: nodeIndex=59, longName="transitionDownB"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(60);

		ParamDefTable[59].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=60, longName="transitionDownB[]"
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(61);
		Children[1] = PDEF_PTR(62);
		Children[2] = PDEF_PTR(63);
		Children[3] = PDEF_PTR(64);
		Children[4] = PDEF_PTR(65);
		Children[5] = PDEF_PTR(66);

		ParamDefTable[60].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=67, longName="transitionDownC"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(68);

		ParamDefTable[67].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=68, longName="transitionDownC[]"
	{
		static Definition* Children[4];
		Children[0] = PDEF_PTR(69);
		Children[1] = PDEF_PTR(70);
		Children[2] = PDEF_PTR(71);
		Children[3] = PDEF_PTR(72);

		ParamDefTable[68].setChildren(Children, 4);
	}

	mBuiltFlag = true;

}
void ClothingPhysicalMeshParameters_0p0::initStrings(void)
{
}

void ClothingPhysicalMeshParameters_0p0::initDynamicArrays(void)
{
	physicalMesh.vertices.buf = NULL;
	physicalMesh.vertices.isAllocated = true;
	physicalMesh.vertices.elementSize = sizeof(physx::PxVec3);
	physicalMesh.vertices.arraySizes[0] = 0;
	physicalMesh.normals.buf = NULL;
	physicalMesh.normals.isAllocated = true;
	physicalMesh.normals.elementSize = sizeof(physx::PxVec3);
	physicalMesh.normals.arraySizes[0] = 0;
	physicalMesh.skinningNormals.buf = NULL;
	physicalMesh.skinningNormals.isAllocated = true;
	physicalMesh.skinningNormals.elementSize = sizeof(physx::PxVec3);
	physicalMesh.skinningNormals.arraySizes[0] = 0;
	physicalMesh.vertexFlags.buf = NULL;
	physicalMesh.vertexFlags.isAllocated = true;
	physicalMesh.vertexFlags.elementSize = sizeof(uint32_t);
	physicalMesh.vertexFlags.arraySizes[0] = 0;
	physicalMesh.constrainCoefficients.buf = NULL;
	physicalMesh.constrainCoefficients.isAllocated = true;
	physicalMesh.constrainCoefficients.elementSize = sizeof(ConstrainCoefficient_Type);
	physicalMesh.constrainCoefficients.arraySizes[0] = 0;
	physicalMesh.boneIndices.buf = NULL;
	physicalMesh.boneIndices.isAllocated = true;
	physicalMesh.boneIndices.elementSize = sizeof(uint16_t);
	physicalMesh.boneIndices.arraySizes[0] = 0;
	physicalMesh.boneWeights.buf = NULL;
	physicalMesh.boneWeights.isAllocated = true;
	physicalMesh.boneWeights.elementSize = sizeof(float);
	physicalMesh.boneWeights.arraySizes[0] = 0;
	physicalMesh.indices.buf = NULL;
	physicalMesh.indices.isAllocated = true;
	physicalMesh.indices.elementSize = sizeof(uint32_t);
	physicalMesh.indices.arraySizes[0] = 0;
	submeshes.buf = NULL;
	submeshes.isAllocated = true;
	submeshes.elementSize = sizeof(PhysicalSubmesh_Type);
	submeshes.arraySizes[0] = 0;
	deformableCookedData.buf = NULL;
	deformableCookedData.isAllocated = true;
	deformableCookedData.elementSize = sizeof(uint8_t);
	deformableCookedData.arraySizes[0] = 0;
	physicalLods.buf = NULL;
	physicalLods.isAllocated = true;
	physicalLods.elementSize = sizeof(PhysicalLod_Type);
	physicalLods.arraySizes[0] = 0;
	transitionUpB.buf = NULL;
	transitionUpB.isAllocated = true;
	transitionUpB.elementSize = sizeof(SkinClothMapB_Type);
	transitionUpB.arraySizes[0] = 0;
	transitionUpC.buf = NULL;
	transitionUpC.isAllocated = true;
	transitionUpC.elementSize = sizeof(SkinClothMapC_Type);
	transitionUpC.arraySizes[0] = 0;
	transitionDownB.buf = NULL;
	transitionDownB.isAllocated = true;
	transitionDownB.elementSize = sizeof(SkinClothMapB_Type);
	transitionDownB.arraySizes[0] = 0;
	transitionDownC.buf = NULL;
	transitionDownC.isAllocated = true;
	transitionDownC.elementSize = sizeof(SkinClothMapC_Type);
	transitionDownC.arraySizes[0] = 0;
}

void ClothingPhysicalMeshParameters_0p0::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	physicalMesh.numVertices = uint32_t(0);
	physicalMesh.numIndices = uint32_t(0);
	physicalMesh.numBonesPerVertex = uint32_t(0);
	physicalMesh.maximumMaxDistance = float(0);
	physicalMesh.shortestEdgeLength = float(0);
	physicalMesh.averageEdgeLength = float(0);
	physicalMesh.isTetrahedralMesh = bool(false);
	deformableCookedDataVersion = uint32_t(0);
	transitionUpThickness = float(0);
	transitionUpOffset = float(0);
	transitionDownThickness = float(0);
	transitionDownOffset = float(0);
	referenceCount = uint32_t(0);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void ClothingPhysicalMeshParameters_0p0::initReferences(void)
{
}

void ClothingPhysicalMeshParameters_0p0::freeDynamicArrays(void)
{
	if (physicalMesh.vertices.isAllocated && physicalMesh.vertices.buf)
	{
		mParameterizedTraits->free(physicalMesh.vertices.buf);
	}
	if (physicalMesh.normals.isAllocated && physicalMesh.normals.buf)
	{
		mParameterizedTraits->free(physicalMesh.normals.buf);
	}
	if (physicalMesh.skinningNormals.isAllocated && physicalMesh.skinningNormals.buf)
	{
		mParameterizedTraits->free(physicalMesh.skinningNormals.buf);
	}
	if (physicalMesh.vertexFlags.isAllocated && physicalMesh.vertexFlags.buf)
	{
		mParameterizedTraits->free(physicalMesh.vertexFlags.buf);
	}
	if (physicalMesh.constrainCoefficients.isAllocated && physicalMesh.constrainCoefficients.buf)
	{
		mParameterizedTraits->free(physicalMesh.constrainCoefficients.buf);
	}
	if (physicalMesh.boneIndices.isAllocated && physicalMesh.boneIndices.buf)
	{
		mParameterizedTraits->free(physicalMesh.boneIndices.buf);
	}
	if (physicalMesh.boneWeights.isAllocated && physicalMesh.boneWeights.buf)
	{
		mParameterizedTraits->free(physicalMesh.boneWeights.buf);
	}
	if (physicalMesh.indices.isAllocated && physicalMesh.indices.buf)
	{
		mParameterizedTraits->free(physicalMesh.indices.buf);
	}
	if (submeshes.isAllocated && submeshes.buf)
	{
		mParameterizedTraits->free(submeshes.buf);
	}
	if (deformableCookedData.isAllocated && deformableCookedData.buf)
	{
		mParameterizedTraits->free(deformableCookedData.buf);
	}
	if (physicalLods.isAllocated && physicalLods.buf)
	{
		mParameterizedTraits->free(physicalLods.buf);
	}
	if (transitionUpB.isAllocated && transitionUpB.buf)
	{
		mParameterizedTraits->free(transitionUpB.buf);
	}
	if (transitionUpC.isAllocated && transitionUpC.buf)
	{
		mParameterizedTraits->free(transitionUpC.buf);
	}
	if (transitionDownB.isAllocated && transitionDownB.buf)
	{
		mParameterizedTraits->free(transitionDownB.buf);
	}
	if (transitionDownC.isAllocated && transitionDownC.buf)
	{
		mParameterizedTraits->free(transitionDownC.buf);
	}
}

void ClothingPhysicalMeshParameters_0p0::freeStrings(void)
{
}

void ClothingPhysicalMeshParameters_0p0::freeReferences(void)
{
}

} // namespace parameterized
} // namespace nvidia
