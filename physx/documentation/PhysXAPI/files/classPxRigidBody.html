<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PxRigidBody Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PhysXLogoBlack.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classPxRigidBody.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classPxRigidBody-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PxRigidBody Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__physics.html">Physics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> is a base class shared between dynamic rigid body objects.  
 <a href="classPxRigidBody.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PxRigidBody_8h_source.html">PxRigidBody.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PxRigidBody:</div>
<div class="dyncontent">
<div class="center"><img src="classPxRigidBody__inherit__graph.png" border="0" usemap="#PxRigidBody_inherit__map" alt="Inheritance graph"/></div>
<map name="PxRigidBody_inherit__map" id="PxRigidBody_inherit__map">
<area shape="rect" id="node5" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body " alt="" coords="5,304,132,331"/>
<area shape="rect" id="node6" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK. " alt="" coords="156,304,275,331"/>
<area shape="rect" id="node2" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD..." alt="" coords="93,155,191,181"/>
<area shape="rect" id="node3" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. " alt="" coords="107,80,177,107"/>
<area shape="rect" id="node4" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection. " alt="" coords="108,5,176,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for PxRigidBody:</div>
<div class="dyncontent">
<div class="center"><img src="classPxRigidBody__coll__graph.png" border="0" usemap="#PxRigidBody_coll__map" alt="Collaboration graph"/></div>
<map name="PxRigidBody_coll__map" id="PxRigidBody_coll__map">
<area shape="rect" id="node2" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD..." alt="" coords="33,261,131,288"/>
<area shape="rect" id="node3" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. " alt="" coords="47,185,117,212"/>
<area shape="rect" id="node4" href="classPxBase.html" title="Base class for objects that can be members of a PxCollection. " alt="" coords="48,109,116,136"/>
<area shape="rect" id="node5" href="classPxFlags.html" title="PxFlags\&lt; PxBaseFlag\l::Enum, PxU16 \&gt;" alt="" coords="5,5,159,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mass Manipulation</div></td></tr>
<tr class="memitem:ab152773926fe7b222d61e982c3cb6adf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf">setCMassLocalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>
<tr class="memdesc:ab152773926fe7b222d61e982c3cb6adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pose of the center of mass relative to the actor.  <a href="#ab152773926fe7b222d61e982c3cb6adf">More...</a><br /></td></tr>
<tr class="separator:ab152773926fe7b222d61e982c3cb6adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdbdab1865112b15201aeabb23877b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#aafdbdab1865112b15201aeabb23877b4">getCMassLocalPose</a> () const =0</td></tr>
<tr class="memdesc:aafdbdab1865112b15201aeabb23877b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the center of mass pose relative to the actor frame.  <a href="#aafdbdab1865112b15201aeabb23877b4">More...</a><br /></td></tr>
<tr class="separator:aafdbdab1865112b15201aeabb23877b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a697a7a4b9bdd2c83a68e84b9bc3a35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35">setMass</a> (PxReal mass)=0</td></tr>
<tr class="memdesc:a8a697a7a4b9bdd2c83a68e84b9bc3a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass of a dynamic actor.  <a href="#a8a697a7a4b9bdd2c83a68e84b9bc3a35">More...</a><br /></td></tr>
<tr class="separator:a8a697a7a4b9bdd2c83a68e84b9bc3a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1c475ca9cc6aebc168ac58256b7284"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a2b1c475ca9cc6aebc168ac58256b7284">getMass</a> () const =0</td></tr>
<tr class="memdesc:a2b1c475ca9cc6aebc168ac58256b7284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the mass of the actor.  <a href="#a2b1c475ca9cc6aebc168ac58256b7284">More...</a><br /></td></tr>
<tr class="separator:a2b1c475ca9cc6aebc168ac58256b7284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c82bd72a216c0460887cf94184560bd"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a4c82bd72a216c0460887cf94184560bd">getInvMass</a> () const =0</td></tr>
<tr class="memdesc:a4c82bd72a216c0460887cf94184560bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the inverse mass of the actor.  <a href="#a4c82bd72a216c0460887cf94184560bd">More...</a><br /></td></tr>
<tr class="separator:a4c82bd72a216c0460887cf94184560bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755d0c8a8d1dd8b29e59d50a6dfda5fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd">setMassSpaceInertiaTensor</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;m)=0</td></tr>
<tr class="memdesc:a755d0c8a8d1dd8b29e59d50a6dfda5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the inertia tensor, using a parameter specified in mass space coordinates.  <a href="#a755d0c8a8d1dd8b29e59d50a6dfda5fd">More...</a><br /></td></tr>
<tr class="separator:a755d0c8a8d1dd8b29e59d50a6dfda5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063cce94190de44d86a15c1b49dd7f71"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a063cce94190de44d86a15c1b49dd7f71">getMassSpaceInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a063cce94190de44d86a15c1b49dd7f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  <a href="#a063cce94190de44d86a15c1b49dd7f71">More...</a><br /></td></tr>
<tr class="separator:a063cce94190de44d86a15c1b49dd7f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63830b4cd24cd6e5e9f5bb2d6a1d3dc3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a63830b4cd24cd6e5e9f5bb2d6a1d3dc3">getMassSpaceInvInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a63830b4cd24cd6e5e9f5bb2d6a1d3dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame.  <a href="#a63830b4cd24cd6e5e9f5bb2d6a1d3dc3">More...</a><br /></td></tr>
<tr class="separator:a63830b4cd24cd6e5e9f5bb2d6a1d3dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Damping</div></td></tr>
<tr class="memitem:ac81d09f36de3f2d1984709b559bb74ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ac81d09f36de3f2d1984709b559bb74ff">setLinearDamping</a> (PxReal linDamp)=0</td></tr>
<tr class="memdesc:ac81d09f36de3f2d1984709b559bb74ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear damping coefficient.  <a href="#ac81d09f36de3f2d1984709b559bb74ff">More...</a><br /></td></tr>
<tr class="separator:ac81d09f36de3f2d1984709b559bb74ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb785dde2e8e0954db807c7ec69a26"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ad7fb785dde2e8e0954db807c7ec69a26">getLinearDamping</a> () const =0</td></tr>
<tr class="memdesc:ad7fb785dde2e8e0954db807c7ec69a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear damping coefficient.  <a href="#ad7fb785dde2e8e0954db807c7ec69a26">More...</a><br /></td></tr>
<tr class="separator:ad7fb785dde2e8e0954db807c7ec69a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8f357ce212cdf05250237073278d0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#adb8f357ce212cdf05250237073278d0c">setAngularDamping</a> (PxReal angDamp)=0</td></tr>
<tr class="memdesc:adb8f357ce212cdf05250237073278d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angular damping coefficient.  <a href="#adb8f357ce212cdf05250237073278d0c">More...</a><br /></td></tr>
<tr class="separator:adb8f357ce212cdf05250237073278d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffbfa748d3a75e79a13dbca92aaa7ff"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#aaffbfa748d3a75e79a13dbca92aaa7ff">getAngularDamping</a> () const =0</td></tr>
<tr class="memdesc:aaffbfa748d3a75e79a13dbca92aaa7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular damping coefficient.  <a href="#aaffbfa748d3a75e79a13dbca92aaa7ff">More...</a><br /></td></tr>
<tr class="separator:aaffbfa748d3a75e79a13dbca92aaa7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Velocity</div></td></tr>
<tr class="memitem:a04bab22deecb716e2cdd7a64b5cfaee7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a04bab22deecb716e2cdd7a64b5cfaee7">getLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:a04bab22deecb716e2cdd7a64b5cfaee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear velocity of an actor.  <a href="#a04bab22deecb716e2cdd7a64b5cfaee7">More...</a><br /></td></tr>
<tr class="separator:a04bab22deecb716e2cdd7a64b5cfaee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aed51d5ddcf81b09a104ad7f0f30c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a0aed51d5ddcf81b09a104ad7f0f30c05">setLinearVelocity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;linVel, bool autowake=true)=0</td></tr>
<tr class="memdesc:a0aed51d5ddcf81b09a104ad7f0f30c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear velocity of the actor.  <a href="#a0aed51d5ddcf81b09a104ad7f0f30c05">More...</a><br /></td></tr>
<tr class="separator:a0aed51d5ddcf81b09a104ad7f0f30c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91b92d6fcf47103b148337749aa93e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#af91b92d6fcf47103b148337749aa93e0">getAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:af91b92d6fcf47103b148337749aa93e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular velocity of the actor.  <a href="#af91b92d6fcf47103b148337749aa93e0">More...</a><br /></td></tr>
<tr class="separator:af91b92d6fcf47103b148337749aa93e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49850630db14af26e019d2550ecfd27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ad49850630db14af26e019d2550ecfd27">setAngularVelocity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;angVel, bool autowake=true)=0</td></tr>
<tr class="memdesc:ad49850630db14af26e019d2550ecfd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angular velocity of the actor.  <a href="#ad49850630db14af26e019d2550ecfd27">More...</a><br /></td></tr>
<tr class="separator:ad49850630db14af26e019d2550ecfd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf8a649186d2b993b0e64d6228706db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#afdf8a649186d2b993b0e64d6228706db">setMaxAngularVelocity</a> (PxReal maxAngVel)=0</td></tr>
<tr class="memdesc:afdf8a649186d2b993b0e64d6228706db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum angular velocity permitted for this actor.  <a href="#afdf8a649186d2b993b0e64d6228706db">More...</a><br /></td></tr>
<tr class="separator:afdf8a649186d2b993b0e64d6228706db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052320915132f7d7f72ede4543b64ad"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a8052320915132f7d7f72ede4543b64ad">getMaxAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:a8052320915132f7d7f72ede4543b64ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <a href="#a8052320915132f7d7f72ede4543b64ad">More...</a><br /></td></tr>
<tr class="separator:a8052320915132f7d7f72ede4543b64ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399c1bb619f89ad1df4400a03a242051"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a399c1bb619f89ad1df4400a03a242051">setMaxLinearVelocity</a> (PxReal maxLinVel)=0</td></tr>
<tr class="memdesc:a399c1bb619f89ad1df4400a03a242051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum linear velocity permitted for this actor.  <a href="#a399c1bb619f89ad1df4400a03a242051">More...</a><br /></td></tr>
<tr class="separator:a399c1bb619f89ad1df4400a03a242051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f7fee01b5d357fdeb840ee4322c7a4"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a00f7fee01b5d357fdeb840ee4322c7a4">getMaxLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:a00f7fee01b5d357fdeb840ee4322c7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <a href="#a00f7fee01b5d357fdeb840ee4322c7a4">More...</a><br /></td></tr>
<tr class="separator:a00f7fee01b5d357fdeb840ee4322c7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxRigidActor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxRigidActor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxRigidActor.html">PxRigidActor</a></td></tr>
<tr class="memitem:a1130f92afcba590b04b1e51b86f5377a inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a1130f92afcba590b04b1e51b86f5377a">release</a> ()=0</td></tr>
<tr class="memdesc:a1130f92afcba590b04b1e51b86f5377a inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the rigid actor object.  <a href="classPxRigidActor.html#a1130f92afcba590b04b1e51b86f5377a">More...</a><br /></td></tr>
<tr class="separator:a1130f92afcba590b04b1e51b86f5377a inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5e3d590e6087c930f8141d40de722 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a6eb5e3d590e6087c930f8141d40de722">getGlobalPose</a> () const =0</td></tr>
<tr class="memdesc:a6eb5e3d590e6087c930f8141d40de722 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the actors world space transform.  <a href="classPxRigidActor.html#a6eb5e3d590e6087c930f8141d40de722">More...</a><br /></td></tr>
<tr class="separator:a6eb5e3d590e6087c930f8141d40de722 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26994d9594ed9a04bd412bdeb2a55f3e inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a26994d9594ed9a04bd412bdeb2a55f3e">setGlobalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, bool autowake=true)=0</td></tr>
<tr class="memdesc:a26994d9594ed9a04bd412bdeb2a55f3e inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for setting an actor's pose in the world.  <a href="classPxRigidActor.html#a26994d9594ed9a04bd412bdeb2a55f3e">More...</a><br /></td></tr>
<tr class="separator:a26994d9594ed9a04bd412bdeb2a55f3e inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022e098ea67bc8ec87f93c2f18a4db6f inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a022e098ea67bc8ec87f93c2f18a4db6f">attachShape</a> (<a class="el" href="classPxShape.html">PxShape</a> &amp;shape)=0</td></tr>
<tr class="separator:a022e098ea67bc8ec87f93c2f18a4db6f inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467f9dc1517978b8d517936a475d3c4c inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a467f9dc1517978b8d517936a475d3c4c">detachShape</a> (<a class="el" href="classPxShape.html">PxShape</a> &amp;shape, bool wakeOnLostTouch=true)=0</td></tr>
<tr class="separator:a467f9dc1517978b8d517936a475d3c4c inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c3534de94642c5980d29f4c49bc112 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#ae5c3534de94642c5980d29f4c49bc112">getNbShapes</a> () const =0</td></tr>
<tr class="memdesc:ae5c3534de94642c5980d29f4c49bc112 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shapes assigned to the actor.  <a href="classPxRigidActor.html#ae5c3534de94642c5980d29f4c49bc112">More...</a><br /></td></tr>
<tr class="separator:ae5c3534de94642c5980d29f4c49bc112 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ef86619d7a6de688b9ef2b0ad7bcec inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#a22ef86619d7a6de688b9ef2b0ad7bcec">getShapes</a> (<a class="el" href="classPxShape.html">PxShape</a> **userBuffer, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>
<tr class="memdesc:a22ef86619d7a6de688b9ef2b0ad7bcec inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the shape pointers belonging to the actor.  <a href="classPxRigidActor.html#a22ef86619d7a6de688b9ef2b0ad7bcec">More...</a><br /></td></tr>
<tr class="separator:a22ef86619d7a6de688b9ef2b0ad7bcec inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad941cfa63351e7ff6095a4afbe2d9172 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#ad941cfa63351e7ff6095a4afbe2d9172">getNbConstraints</a> () const =0</td></tr>
<tr class="memdesc:ad941cfa63351e7ff6095a4afbe2d9172 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraint shaders attached to the actor.  <a href="classPxRigidActor.html#ad941cfa63351e7ff6095a4afbe2d9172">More...</a><br /></td></tr>
<tr class="separator:ad941cfa63351e7ff6095a4afbe2d9172 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88777d5457f87247f5625094eb2be57 inherit pub_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#ac88777d5457f87247f5625094eb2be57">getConstraints</a> (<a class="el" href="classPxConstraint.html">PxConstraint</a> **userBuffer, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> startIndex=0) const =0</td></tr>
<tr class="memdesc:ac88777d5457f87247f5625094eb2be57 inherit pub_methods_classPxRigidActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the constraint shader pointers belonging to the actor.  <a href="classPxRigidActor.html#ac88777d5457f87247f5625094eb2be57">More...</a><br /></td></tr>
<tr class="separator:ac88777d5457f87247f5625094eb2be57 inherit pub_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxActor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structPxActorType.html#a25c5a270f1f5c1955a00d7554f7688d7">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a76a3489218f85ce9fe3ffb883ba8ce63">getType</a> () const =0</td></tr>
<tr class="memdesc:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <a href="classPxActor.html#a76a3489218f85ce9fe3ffb883ba8ce63">More...</a><br /></td></tr>
<tr class="separator:a76a3489218f85ce9fe3ffb883ba8ce63 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxScene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a2bf2e48b1960ef8e4fc1a437473bd7a3">getScene</a> () const =0</td></tr>
<tr class="memdesc:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <a href="classPxActor.html#a2bf2e48b1960ef8e4fc1a437473bd7a3">More...</a><br /></td></tr>
<tr class="separator:a2bf2e48b1960ef8e4fc1a437473bd7a3 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e" title="Retrieves the name string set with setName(). ">getName()</a>.  <a href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758">More...</a><br /></td></tr>
<tr class="separator:afdcfb185892a5c8311fd0d825b0ce758 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e">getName</a> () const =0</td></tr>
<tr class="memdesc:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classPxActor.html#afdcfb185892a5c8311fd0d825b0ce758" title="Sets a name string for the object that can be retrieved with getName(). ">setName()</a>.  <a href="classPxActor.html#a1ae86d992066567c5d6bca5fe2dc656e">More...</a><br /></td></tr>
<tr class="separator:a1ae86d992066567c5d6bca5fe2dc656e inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab89ce3ee6d27b580063d131a417721 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#acab89ce3ee6d27b580063d131a417721">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:acab89ce3ee6d27b580063d131a417721 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the actor.  <a href="classPxActor.html#acab89ce3ee6d27b580063d131a417721">More...</a><br /></td></tr>
<tr class="separator:acab89ce3ee6d27b580063d131a417721 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f">setActorFlag</a> (<a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1d">PxActorFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular actor flag.  <a href="classPxActor.html#ae24ff3f3ed0cb2a138b382fd0720b94f">More...</a><br /></td></tr>
<tr class="separator:ae24ff3f3ed0cb2a138b382fd0720b94f inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#af60720e190324e8ff36281a2360c6043">setActorFlags</a> (<a class="el" href="group__physics.html#ga468ad85db838378f0c58cfd02a96949b">PxActorFlags</a> inFlags)=0</td></tr>
<tr class="memdesc:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the actor flags  <a href="classPxActor.html#af60720e190324e8ff36281a2360c6043">More...</a><br /></td></tr>
<tr class="separator:af60720e190324e8ff36281a2360c6043 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#ga468ad85db838378f0c58cfd02a96949b">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#afb92fb228de76bbcd42210d060b558d1">getActorFlags</a> () const =0</td></tr>
<tr class="memdesc:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK. ">PxActor</a> flags.  <a href="classPxActor.html#afb92fb228de76bbcd42210d060b558d1">More...</a><br /></td></tr>
<tr class="separator:afb92fb228de76bbcd42210d060b558d1 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a614c46687cf76eb219ce47927fc90824">setDominanceGroup</a> (<a class="el" href="group__physics.html#gaf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> dominanceGroup)=0</td></tr>
<tr class="memdesc:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <a href="classPxActor.html#a614c46687cf76eb219ce47927fc90824">More...</a><br /></td></tr>
<tr class="separator:a614c46687cf76eb219ce47927fc90824 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#gaf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a24602fee489b3e797ff0f82613eef755">getDominanceGroup</a> () const =0</td></tr>
<tr class="memdesc:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classPxActor.html#a614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier. ">setDominanceGroup()</a>.  <a href="classPxActor.html#a24602fee489b3e797ff0f82613eef755">More...</a><br /></td></tr>
<tr class="separator:a24602fee489b3e797ff0f82613eef755 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a9bb8613863cf1d73e4d0c0227f25bc6e">setOwnerClient</a> (<a class="el" href="PxClient_8h.html#acb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> inClient)=0</td></tr>
<tr class="memdesc:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner client of an actor.  <a href="classPxActor.html#a9bb8613863cf1d73e4d0c0227f25bc6e">More...</a><br /></td></tr>
<tr class="separator:a9bb8613863cf1d73e4d0c0227f25bc6e inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="PxClient_8h.html#acb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a660828fb83c91f0ada2ca43e06aa2b35">getOwnerClient</a> () const =0</td></tr>
<tr class="memdesc:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner client that was specified with at creation time.  <a href="classPxActor.html#a660828fb83c91f0ada2ca43e06aa2b35">More...</a><br /></td></tr>
<tr class="separator:a660828fb83c91f0ada2ca43e06aa2b35 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#aaedfdd3e9acc77afc2fc0ba51d968876">getAggregate</a> () const =0</td></tr>
<tr class="memdesc:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the aggregate the actor might be a part of.  <a href="classPxActor.html#aaedfdd3e9acc77afc2fc0ba51d968876">More...</a><br /></td></tr>
<tr class="separator:aaedfdd3e9acc77afc2fc0ba51d968876 inherit pub_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classPxBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a67fe206d8897ddce896c371ac8d789a9 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a67fe206d8897ddce896c371ac8d789a9">getConcreteTypeName</a> () const =0</td></tr>
<tr class="memdesc:a67fe206d8897ddce896c371ac8d789a9 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <a href="classPxBase.html#a67fe206d8897ddce896c371ac8d789a9">More...</a><br /></td></tr>
<tr class="separator:a67fe206d8897ddce896c371ac8d789a9 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a4bc720adef86ea68bfb5845f0e104d23">is</a> ()</td></tr>
<tr class="separator:a4bc720adef86ea68bfb5845f0e104d23 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a85aa50ac0e5670a2be64411fea62b5e3">is</a> () const</td></tr>
<tr class="separator:a85aa50ac0e5670a2be64411fea62b5e3 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#ab4e0691a08e49631dc60014d49c7585f">getConcreteType</a> () const</td></tr>
<tr class="memdesc:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns concrete type of object.  <a href="classPxBase.html#ab4e0691a08e49631dc60014d49c7585f">More...</a><br /></td></tr>
<tr class="separator:ab4e0691a08e49631dc60014d49c7585f inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a1dd20bb574075df904e1878f2e771ef9">setBaseFlag</a> (<a class="el" href="structPxBaseFlag.html#ac258de0c7adaa37f81b6ab1b0c86a6ee">PxBaseFlag::Enum</a> flag, bool value)</td></tr>
<tr class="memdesc:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="structPxBaseFlag.html" title="Flags for PxBase. ">PxBaseFlag</a>.  <a href="classPxBase.html#a1dd20bb574075df904e1878f2e771ef9">More...</a><br /></td></tr>
<tr class="separator:a1dd20bb574075df904e1878f2e771ef9 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#afb391b692c561df0a54c413785e4ebd0">setBaseFlags</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> inFlags)</td></tr>
<tr class="memdesc:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PxBaseFlags.  <a href="classPxBase.html#afb391b692c561df0a54c413785e4ebd0">More...</a><br /></td></tr>
<tr class="separator:afb391b692c561df0a54c413785e4ebd0 inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#ad9b10efae7733ff9c8b8d3b7d90a9a5f">getBaseFlags</a> () const</td></tr>
<tr class="memdesc:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns PxBaseFlags.  <a href="classPxBase.html#ad9b10efae7733ff9c8b8d3b7d90a9a5f">More...</a><br /></td></tr>
<tr class="separator:ad9b10efae7733ff9c8b8d3b7d90a9a5f inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a38952fcb80e99f1f5dbf774a75ac2c3d">isReleasable</a> () const</td></tr>
<tr class="memdesc:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the object is subordinate.  <a href="classPxBase.html#a38952fcb80e99f1f5dbf774a75ac2c3d">More...</a><br /></td></tr>
<tr class="separator:a38952fcb80e99f1f5dbf774a75ac2c3d inherit pub_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Forces</h2></td></tr>
<tr class="memitem:a22b0a1ef0b6c5656a6063c5c38f5679c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a22b0a1ef0b6c5656a6063c5c38f5679c">addForce</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;<a class="el" href="PxArticulationReducedCoordinate_8h.html#a1f5925a4680ca8dff39369ff8d47ab7c">force</a>, <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:a22b0a1ef0b6c5656a6063c5c38f5679c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass.  <a href="#a22b0a1ef0b6c5656a6063c5c38f5679c">More...</a><br /></td></tr>
<tr class="separator:a22b0a1ef0b6c5656a6063c5c38f5679c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb04ffc816d45afff2d04e93d7446e79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#acb04ffc816d45afff2d04e93d7446e79">addTorque</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;<a class="el" href="PxArticulationReducedCoordinate_8h.html#abdcc8bb9f78d81acf11aabbf3367d09d">torque</a>, <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:acb04ffc816d45afff2d04e93d7446e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the actor.  <a href="#acb04ffc816d45afff2d04e93d7446e79">More...</a><br /></td></tr>
<tr class="separator:acb04ffc816d45afff2d04e93d7446e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe5174aa160a07d488de2a18ba61f94"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#aefe5174aa160a07d488de2a18ba61f94">clearForce</a> (<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:aefe5174aa160a07d488de2a18ba61f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the accumulated forces (sets the accumulated force back to zero).  <a href="#aefe5174aa160a07d488de2a18ba61f94">More...</a><br /></td></tr>
<tr class="separator:aefe5174aa160a07d488de2a18ba61f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae251132385cc0b082b612d709aa4375d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ae251132385cc0b082b612d709aa4375d">clearTorque</a> (<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:ae251132385cc0b082b612d709aa4375d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the impulsive torque defined in the global coordinate frame to the actor.  <a href="#ae251132385cc0b082b612d709aa4375d">More...</a><br /></td></tr>
<tr class="separator:ae251132385cc0b082b612d709aa4375d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cf856d4059ff6b422b2c58f91d242f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ae1cf856d4059ff6b422b2c58f91d242f">setForceAndTorque</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;<a class="el" href="PxArticulationReducedCoordinate_8h.html#a1f5925a4680ca8dff39369ff8d47ab7c">force</a>, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;<a class="el" href="PxArticulationReducedCoordinate_8h.html#abdcc8bb9f78d81acf11aabbf3367d09d">torque</a>, <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=<a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:ae1cf856d4059ff6b422b2c58f91d242f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the impulsive force and torque defined in the global coordinate frame to the actor.  <a href="#ae1cf856d4059ff6b422b2c58f91d242f">More...</a><br /></td></tr>
<tr class="separator:ae1cf856d4059ff6b422b2c58f91d242f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b23b890404b1010bf0b67a225bd22e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a9b23b890404b1010bf0b67a225bd22e7">setRigidBodyFlag</a> (<a class="el" href="structPxRigidBodyFlag.html#a5fd4878ae66a98c030a9d976e8ba8596">PxRigidBodyFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:a9b23b890404b1010bf0b67a225bd22e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular rigid body flag.  <a href="#a9b23b890404b1010bf0b67a225bd22e7">More...</a><br /></td></tr>
<tr class="separator:a9b23b890404b1010bf0b67a225bd22e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6f3afd71605e037a5de47955d941e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a9e6f3afd71605e037a5de47955d941e0">setRigidBodyFlags</a> (<a class="el" href="group__physics.html#ga2ab6803c803ae6372791ff060068c6a1">PxRigidBodyFlags</a> inFlags)=0</td></tr>
<tr class="separator:a9e6f3afd71605e037a5de47955d941e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef3c66318db72f2dd2c1b0d20513f18"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__physics.html#ga2ab6803c803ae6372791ff060068c6a1">PxRigidBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a2ef3c66318db72f2dd2c1b0d20513f18">getRigidBodyFlags</a> () const =0</td></tr>
<tr class="memdesc:a2ef3c66318db72f2dd2c1b0d20513f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> flags.  <a href="#a2ef3c66318db72f2dd2c1b0d20513f18">More...</a><br /></td></tr>
<tr class="separator:a2ef3c66318db72f2dd2c1b0d20513f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f4fe582726801cb09c2381de0c144d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#ac6f4fe582726801cb09c2381de0c144d">setMinCCDAdvanceCoefficient</a> (PxReal advanceCoefficient)=0</td></tr>
<tr class="memdesc:ac6f4fe582726801cb09c2381de0c144d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CCD minimum advance coefficient.  <a href="#ac6f4fe582726801cb09c2381de0c144d">More...</a><br /></td></tr>
<tr class="separator:ac6f4fe582726801cb09c2381de0c144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae787a717c8468dbf67345dde14ba85"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#abae787a717c8468dbf67345dde14ba85">getMinCCDAdvanceCoefficient</a> () const =0</td></tr>
<tr class="memdesc:abae787a717c8468dbf67345dde14ba85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CCD minimum advance coefficient.  <a href="#abae787a717c8468dbf67345dde14ba85">More...</a><br /></td></tr>
<tr class="separator:abae787a717c8468dbf67345dde14ba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ce18fdc6cb81c0bfb46590db0867d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a261ce18fdc6cb81c0bfb46590db0867d">setMaxDepenetrationVelocity</a> (PxReal biasClamp)=0</td></tr>
<tr class="memdesc:a261ce18fdc6cb81c0bfb46590db0867d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <a href="#a261ce18fdc6cb81c0bfb46590db0867d">More...</a><br /></td></tr>
<tr class="separator:a261ce18fdc6cb81c0bfb46590db0867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3304d26a39bbdd99dc0ad51d1d99aec4"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a3304d26a39bbdd99dc0ad51d1d99aec4">getMaxDepenetrationVelocity</a> () const =0</td></tr>
<tr class="memdesc:a3304d26a39bbdd99dc0ad51d1d99aec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <a href="#a3304d26a39bbdd99dc0ad51d1d99aec4">More...</a><br /></td></tr>
<tr class="separator:a3304d26a39bbdd99dc0ad51d1d99aec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3bbe100e644995742f80f19ea8f250"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a1a3bbe100e644995742f80f19ea8f250">setMaxContactImpulse</a> (PxReal <a class="el" href="PxContact_8h.html#a0a05cbea8c3ce31569c312d33d562f08">maxImpulse</a>)=0</td></tr>
<tr class="memdesc:a1a3bbe100e644995742f80f19ea8f250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body.  <a href="#a1a3bbe100e644995742f80f19ea8f250">More...</a><br /></td></tr>
<tr class="separator:a1a3bbe100e644995742f80f19ea8f250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9e9e7946ab265013229612aad4c3c7"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a2f9e9e7946ab265013229612aad4c3c7">getMaxContactImpulse</a> () const =0</td></tr>
<tr class="memdesc:a2f9e9e7946ab265013229612aad4c3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum impulse that may be applied at a contact.  <a href="#a2f9e9e7946ab265013229612aad4c3c7">More...</a><br /></td></tr>
<tr class="separator:a2f9e9e7946ab265013229612aad4c3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238775889dd7a555d700fd8cd65623e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a238775889dd7a555d700fd8cd65623e9">getInternalIslandNodeIndex</a> () const =0</td></tr>
<tr class="memdesc:a238775889dd7a555d700fd8cd65623e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the island node index that only for internal use only.  <a href="#a238775889dd7a555d700fd8cd65623e9">More...</a><br /></td></tr>
<tr class="separator:a238775889dd7a555d700fd8cd65623e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf18dc769f8d1d3da7760097fa699acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#adf18dc769f8d1d3da7760097fa699acb">PxRigidBody</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:adf18dc769f8d1d3da7760097fa699acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d4e7068063768f6029a975ff5d41e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a14d4e7068063768f6029a975ff5d41e4">PxRigidBody</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a14d4e7068063768f6029a975ff5d41e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ff64730b95c9c36b653ffee707e8a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a229ff64730b95c9c36b653ffee707e8a">~PxRigidBody</a> ()</td></tr>
<tr class="separator:a229ff64730b95c9c36b653ffee707e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126446a6de640cdc08d339911f826270"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#a126446a6de640cdc08d339911f826270">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a126446a6de640cdc08d339911f826270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <a href="#a126446a6de640cdc08d339911f826270">More...</a><br /></td></tr>
<tr class="separator:a126446a6de640cdc08d339911f826270"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classPxActor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ace426ce4cca4de88806beee01eb4b87e">userData</a></td></tr>
<tr class="memdesc:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="classPxActor.html#ace426ce4cca4de88806beee01eb4b87e">More...</a><br /></td></tr>
<tr class="separator:ace426ce4cca4de88806beee01eb4b87e inherit pub_attribs_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxRigidActor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxRigidActor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxRigidActor.html">PxRigidActor</a></td></tr>
<tr class="memitem:aea61d8192d25e64cefbbdc5f6d68a39b inherit pro_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#aea61d8192d25e64cefbbdc5f6d68a39b">PxRigidActor</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:aea61d8192d25e64cefbbdc5f6d68a39b inherit pro_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3690608611b90d1efd033e804fd774 inherit pro_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#abc3690608611b90d1efd033e804fd774">PxRigidActor</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:abc3690608611b90d1efd033e804fd774 inherit pro_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa01a5b7ff077d01da077a5c8163609f inherit pro_methods_classPxRigidActor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#aaa01a5b7ff077d01da077a5c8163609f">~PxRigidActor</a> ()</td></tr>
<tr class="separator:aaa01a5b7ff077d01da077a5c8163609f inherit pro_methods_classPxRigidActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxActor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxActor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxActor.html">PxActor</a></td></tr>
<tr class="memitem:a05d86747e2fc14c89497fa06c8f0f252 inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a05d86747e2fc14c89497fa06c8f0f252">PxActor</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a05d86747e2fc14c89497fa06c8f0f252 inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1780362a59125a7d22619937b2d7a511 inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#a1780362a59125a7d22619937b2d7a511">PxActor</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a1780362a59125a7d22619937b2d7a511 inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c683780b093e7c9348b9e0fd8836d inherit pro_methods_classPxActor"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxActor.html#ad20c683780b093e7c9348b9e0fd8836d">~PxActor</a> ()</td></tr>
<tr class="separator:ad20c683780b093e7c9348b9e0fd8836d inherit pro_methods_classPxActor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classPxBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a263f1ef821c74058ce9335e06cb842a4">PxBase</a> (<a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a> concreteType, <a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor setting concrete type and base flags.  <a href="classPxBase.html#a263f1ef821c74058ce9335e06cb842a4">More...</a><br /></td></tr>
<tr class="separator:a263f1ef821c74058ce9335e06cb842a4 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a58b979202e7382701f74977fe3dd5c6f">PxBase</a> (<a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor setting base flags.  <a href="classPxBase.html#a58b979202e7382701f74977fe3dd5c6f">More...</a><br /></td></tr>
<tr class="separator:a58b979202e7382701f74977fe3dd5c6f inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#adfbf62dc32775b068db1c74c7fd3d982">~PxBase</a> ()</td></tr>
<tr class="memdesc:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classPxBase.html#adfbf62dc32775b068db1c74c7fd3d982">More...</a><br /></td></tr>
<tr class="separator:adfbf62dc32775b068db1c74c7fd3d982 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPxBase.html#a3782ca64c8f12c41443f604e300fc207">typeMatch</a> () const</td></tr>
<tr class="separator:a3782ca64c8f12c41443f604e300fc207 inherit pro_methods_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classPxBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classPxBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classPxBase.html">PxBase</a></td></tr>
<tr class="memitem:a1abe9d19726e1f8f8e56abeb2269b5d4 inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#a1abe9d19726e1f8f8e56abeb2269b5d4">mConcreteType</a></td></tr>
<tr class="separator:a1abe9d19726e1f8f8e56abeb2269b5d4 inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7105f65905ecb9f6f7993ba28b712d inherit pro_attribs_classPxBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBase.html#aff7105f65905ecb9f6f7993ba28b712d">mBaseFlags</a></td></tr>
<tr class="separator:aff7105f65905ecb9f6f7993ba28b712d inherit pro_attribs_classPxBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> is a base class shared between dynamic rigid body objects. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adf18dc769f8d1d3da7760097fa699acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf18dc769f8d1d3da7760097fa699acb">&#9670;&nbsp;</a></span>PxRigidBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> PxRigidBody::PxRigidBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gac1fb4b256a5d900d394e89db170a2b79">PxType</a>&#160;</td>
          <td class="paramname"><em>concreteType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td>
          <td class="paramname"><em>baseFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14d4e7068063768f6029a975ff5d41e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d4e7068063768f6029a975ff5d41e4">&#9670;&nbsp;</a></span>PxRigidBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> PxRigidBody::PxRigidBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#ga1e3721588799f5fbb18d76e4aab7d018">PxBaseFlags</a>&#160;</td>
          <td class="paramname"><em>baseFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a229ff64730b95c9c36b653ffee707e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229ff64730b95c9c36b653ffee707e8a">&#9670;&nbsp;</a></span>~PxRigidBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxRigidBody::~PxRigidBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a22b0a1ef0b6c5656a6063c5c38f5679c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b0a1ef0b6c5656a6063c5c38f5679c">&#9670;&nbsp;</a></span>addForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::addForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass. </p>
<p><b>This will not induce a torque</b>.</p>
<p><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> determines if the force is to be conventional or impulsive.</p>
<p>Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545ad8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just like a force excep...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force ">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse mass and then using <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545ad8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just like a force excep...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> respectively.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
The force modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
if this is called on an articulation link, only the link is updated, not the entire articulation.</dd>
<dd>
see <a class="el" href="classPxRigidBodyExt.html#aa0684e41c619824229cdedb47e06563a" title="Compute the change to linear and angular velocity that would occur if an impulsive force and torque w...">PxRigidBodyExt::computeVelocityDeltaFromImpulse</a> for details of how to compute the change in linear velocity that will arise from the application of an impulsive force, where an impulsive force is applied force multiplied by a timestep.</dd></dl>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default) or the force is non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>Force/Impulse to apply defined in the global frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Specify if the call should wake up the actor if it is currently asleep. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#acb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor. ">addTorque</a> </dd></dl>

</div>
</div>
<a id="acb04ffc816d45afff2d04e93d7446e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb04ffc816d45afff2d04e93d7446e79">&#9670;&nbsp;</a></span>addTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::addTorque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an impulsive torque defined in the global coordinate frame to the actor. </p>
<p><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> determines if the torque is to be conventional or impulsive.</p>
<p>Each actor has an angular acceleration and an angular velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545ad8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just like a force excep...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force ">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse inertia and then using <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545ad8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just like a force excep...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> respectively.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
The force modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
if this called on an articulation link, only the link is updated, not the entire articulation.</dd>
<dd>
see <a class="el" href="classPxRigidBodyExt.html#aa0684e41c619824229cdedb47e06563a" title="Compute the change to linear and angular velocity that would occur if an impulsive force and torque w...">PxRigidBodyExt::computeVelocityDeltaFromImpulse</a> for details of how to compute the change in angular velocity that will arise from the application of an impulsive torque, where an impulsive torque is an applied torque multiplied by a timestep.</dd></dl>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default) or the torque is non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">torque</td><td>Torque to apply defined in the global frame. <b>Range:</b> torque vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>whether to wake up the object if it is asleep. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#a22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mas...">addForce()</a> </dd></dl>

</div>
</div>
<a id="aefe5174aa160a07d488de2a18ba61f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe5174aa160a07d488de2a18ba61f94">&#9670;&nbsp;</a></span>clearForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::clearForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the accumulated forces (sets the accumulated force back to zero). </p>
<p>Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545ad8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just like a force excep...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force ">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> also modify these same accumulators (see <a class="el" href="classPxRigidBody.html#a22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mas...">PxRigidBody::addForce()</a> for details); therefore the effect of calling clearForce(PxForceMode::eFORCE) is equivalent to calling clearForce(PxForceMode::eACCELERATION), and the effect of calling clearForce(PxForceMode::eIMPULSE) is equivalent to calling clearForce(PxForceMode::eVELOCITY_CHANGE).</p>
<p><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> determines if the cleared force is to be conventional or impulsive.</p>
<dl class="section note"><dt>Note</dt><dd>The force modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when clearing the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#a22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mas...">addForce</a> </dd></dl>

</div>
</div>
<a id="ae251132385cc0b082b612d709aa4375d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae251132385cc0b082b612d709aa4375d">&#9670;&nbsp;</a></span>clearTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::clearTorque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the impulsive torque defined in the global coordinate frame to the actor. </p>
<p><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> determines if the cleared torque is to be conventional or impulsive.</p>
<p>Each actor has an angular acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545ad8a356d2419566d7325ce7017c923a50" title="parameter has unit of distance/ time^2, i.e. an acceleration. It gets treated just like a force excep...">PxForceMode::eACCELERATION</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a" title="parameter has unit of mass * distance/ time^2, i.e. a force ">PxForceMode::eFORCE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> also modify these same accumulators (see <a class="el" href="classPxRigidBody.html#acb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor. ">PxRigidBody::addTorque()</a> for details); therefore the effect of calling clearTorque(PxForceMode::eFORCE) is equivalent to calling clearTorque(PxForceMode::eACCELERATION), and the effect of calling clearTorque(PxForceMode::eIMPULSE) is equivalent to calling clearTorque(PxForceMode::eVELOCITY_CHANGE).</p>
<dl class="section note"><dt>Note</dt><dd>The force modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when clearing the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#acb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor. ">addTorque</a> </dd></dl>

</div>
</div>
<a id="aaffbfa748d3a75e79a13dbca92aaa7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffbfa748d3a75e79a13dbca92aaa7ff">&#9670;&nbsp;</a></span>getAngularDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getAngularDamping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the angular damping coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The angular damping coefficient associated with this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#adb8f357ce212cdf05250237073278d0c" title="Sets the angular damping coefficient. ">setAngularDamping()</a> <a class="el" href="classPxRigidBody.html#ad7fb785dde2e8e0954db807c7ec69a26" title="Retrieves the linear damping coefficient. ">getLinearDamping()</a> </dd></dl>

</div>
</div>
<a id="af91b92d6fcf47103b148337749aa93e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91b92d6fcf47103b148337749aa93e0">&#9670;&nbsp;</a></span>getAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the angular velocity of the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The angular velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#ad49850630db14af26e019d2550ecfd27" title="Sets the angular velocity of the actor. ">PxRigidDynamic.setAngularVelocity()</a> <a class="el" href="classPxRigidBody.html#a04bab22deecb716e2cdd7a64b5cfaee7" title="Retrieves the linear velocity of an actor. ">getLinearVelocity()</a> </dd></dl>

</div>
</div>
<a id="aafdbdab1865112b15201aeabb23877b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdbdab1865112b15201aeabb23877b4">&#9670;&nbsp;</a></span>getCMassLocalPose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTransform.html">PxTransform</a> PxRigidBody::getCMassLocalPose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the center of mass pose relative to the actor frame. </p>
<dl class="section return"><dt>Returns</dt><dd>The center of mass pose relative to the actor frame.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor. ">setCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div>
<a id="a238775889dd7a555d700fd8cd65623e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238775889dd7a555d700fd8cd65623e9">&#9670;&nbsp;</a></span>getInternalIslandNodeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gacce5749db3dcfb916e98c253374264ed">PxU32</a> PxRigidBody::getInternalIslandNodeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the island node index that only for internal use only. </p>
<dl class="section return"><dt>Returns</dt><dd>The island node index that only for internal use only </dd></dl>

</div>
</div>
<a id="a4c82bd72a216c0460887cf94184560bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c82bd72a216c0460887cf94184560bd">&#9670;&nbsp;</a></span>getInvMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getInvMass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the inverse mass of the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The inverse mass of this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor. ">setMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates. ">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div>
<a id="ad7fb785dde2e8e0954db807c7ec69a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fb785dde2e8e0954db807c7ec69a26">&#9670;&nbsp;</a></span>getLinearDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getLinearDamping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the linear damping coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The linear damping coefficient associated with this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#ac81d09f36de3f2d1984709b559bb74ff" title="Sets the linear damping coefficient. ">setLinearDamping()</a> <a class="el" href="classPxRigidBody.html#aaffbfa748d3a75e79a13dbca92aaa7ff" title="Retrieves the angular damping coefficient. ">getAngularDamping()</a> </dd></dl>

</div>
</div>
<a id="a04bab22deecb716e2cdd7a64b5cfaee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bab22deecb716e2cdd7a64b5cfaee7">&#9670;&nbsp;</a></span>getLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the linear velocity of an actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The linear velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a0aed51d5ddcf81b09a104ad7f0f30c05" title="Sets the linear velocity of the actor. ">PxRigidDynamic.setLinearVelocity()</a> <a class="el" href="classPxRigidBody.html#af91b92d6fcf47103b148337749aa93e0" title="Retrieves the angular velocity of the actor. ">getAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="a2b1c475ca9cc6aebc168ac58256b7284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1c475ca9cc6aebc168ac58256b7284">&#9670;&nbsp;</a></span>getMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the mass of the actor. </p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 is interpreted as infinite mass.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The mass of this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor. ">setMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates. ">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div>
<a id="a063cce94190de44d86a15c1b49dd7f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063cce94190de44d86a15c1b49dd7f71">&#9670;&nbsp;</a></span>getMassSpaceInertiaTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getMassSpaceInertiaTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame. </p>
<p>This method retrieves a mass frame inertia vector.</p>
<dl class="section return"><dt>Returns</dt><dd>The mass space inertia tensor of this actor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>PxRigidBodyDesc.massSpaceInertia <a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates. ">setMassSpaceInertiaTensor()</a> <a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor. ">setMass()</a> <a class="el" href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor. ">setCMassLocalPose()</a> </dd></dl>

</div>
</div>
<a id="a63830b4cd24cd6e5e9f5bb2d6a1d3dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63830b4cd24cd6e5e9f5bb2d6a1d3dc3">&#9670;&nbsp;</a></span>getMassSpaceInvInertiaTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getMassSpaceInvInertiaTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame. </p>
<p>This method retrieves a mass frame inverse inertia vector.</p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The mass space inverse inertia tensor of this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>PxRigidBodyDesc.massSpaceInertia <a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates. ">setMassSpaceInertiaTensor()</a> <a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor. ">setMass()</a> <a class="el" href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor. ">setCMassLocalPose()</a> </dd></dl>

</div>
</div>
<a id="a8052320915132f7d7f72ede4543b64ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8052320915132f7d7f72ede4543b64ad">&#9670;&nbsp;</a></span>getMaxAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMaxAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the maximum angular velocity permitted for this actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed angular velocity for this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#afdf8a649186d2b993b0e64d6228706db" title="Lets you set the maximum angular velocity permitted for this actor. ">setMaxAngularVelocity</a> </dd></dl>

</div>
</div>
<a id="a2f9e9e7946ab265013229612aad4c3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9e9e7946ab265013229612aad4c3c7">&#9670;&nbsp;</a></span>getMaxContactImpulse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMaxContactImpulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum impulse that may be applied at a contact. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum impulse that may be applied at a contact</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a1a3bbe100e644995742f80f19ea8f250" title="Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact betwee...">setMaxContactImpulse</a> </dd></dl>

</div>
</div>
<a id="a3304d26a39bbdd99dc0ad51d1d99aec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3304d26a39bbdd99dc0ad51d1d99aec4">&#9670;&nbsp;</a></span>getMaxDepenetrationVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMaxDepenetrationVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum penetration bias applied by the solver. </dd></dl>

</div>
</div>
<a id="a00f7fee01b5d357fdeb840ee4322c7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f7fee01b5d357fdeb840ee4322c7a4">&#9670;&nbsp;</a></span>getMaxLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMaxLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the maximum angular velocity permitted for this actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed angular velocity for this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a399c1bb619f89ad1df4400a03a242051" title="Lets you set the maximum linear velocity permitted for this actor. ">setMaxLinearVelocity</a> </dd></dl>

</div>
</div>
<a id="abae787a717c8468dbf67345dde14ba85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae787a717c8468dbf67345dde14ba85">&#9670;&nbsp;</a></span>getMinCCDAdvanceCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal PxRigidBody::getMinCCDAdvanceCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the CCD minimum advance coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the CCD min advance coefficient.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#ac6f4fe582726801cb09c2381de0c144d" title="Sets the CCD minimum advance coefficient. ">setMinCCDAdvanceCoefficient</a> </dd></dl>

</div>
</div>
<a id="a2ef3c66318db72f2dd2c1b0d20513f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef3c66318db72f2dd2c1b0d20513f18">&#9670;&nbsp;</a></span>getRigidBodyFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__physics.html#ga2ab6803c803ae6372791ff060068c6a1">PxRigidBodyFlags</a> PxRigidBody::getRigidBodyFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> flags. </p>
<p>See the list of flags <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a></p>
<dl class="section return"><dt>Returns</dt><dd>The values of the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> flags.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#a9b23b890404b1010bf0b67a225bd22e7" title="Raises or clears a particular rigid body flag. ">setRigidBodyFlag()</a> </dd></dl>

</div>
</div>
<a id="a126446a6de640cdc08d339911f826270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126446a6de640cdc08d339911f826270">&#9670;&nbsp;</a></span>isKindOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidBody::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>superClass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a given type name matches with the type of this instance. </p>

<p>Reimplemented from <a class="el" href="classPxRigidActor.html#a2e82b1515fd2c875edca2762cfe76f81">PxRigidActor</a>.</p>

<p>Reimplemented in <a class="el" href="classPxRigidDynamic.html#a2e1d23ebdce36455824949be867128d1">PxRigidDynamic</a>, and <a class="el" href="classPxArticulationLink.html#a6e3fa396e7207fa370644a23db1467ab">PxArticulationLink</a>.</p>

<p class="reference">References <a class="el" href="classPxRigidActor.html#a2e82b1515fd2c875edca2762cfe76f81">PxRigidActor::isKindOf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classPxArticulationLink.html#a6e3fa396e7207fa370644a23db1467ab">PxArticulationLink::isKindOf()</a>, and <a class="el" href="classPxRigidDynamic.html#a2e1d23ebdce36455824949be867128d1">PxRigidDynamic::isKindOf()</a>.</p>

</div>
</div>
<a id="adb8f357ce212cdf05250237073278d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8f357ce212cdf05250237073278d0c">&#9670;&nbsp;</a></span>setAngularDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setAngularDamping </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>angDamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the angular damping coefficient. </p>
<p>Zero represents no damping.</p>
<p>The angular damping coefficient must be nonnegative.</p>
<p><b>Default:</b> 0.05</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angDamp</td><td>Angular damping coefficient. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#aaffbfa748d3a75e79a13dbca92aaa7ff" title="Retrieves the angular damping coefficient. ">getAngularDamping()</a> <a class="el" href="classPxRigidBody.html#ac81d09f36de3f2d1984709b559bb74ff" title="Sets the linear damping coefficient. ">setLinearDamping()</a> </dd></dl>

</div>
</div>
<a id="ad49850630db14af26e019d2550ecfd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49850630db14af26e019d2550ecfd27">&#9670;&nbsp;</a></span>setAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>angVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the angular velocity of the actor. </p>
<p>Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.</p>
<p><b>Default:</b> (0.0, 0.0, 0.0)</p>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, the autowake parameter is true (default) or the new velocity is non-zero</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angVel</td><td>New angular velocity of actor. <b>Range:</b> angular velocity vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Whether to wake the object up if it is asleep and the velocity is non-zero. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#af91b92d6fcf47103b148337749aa93e0" title="Retrieves the angular velocity of the actor. ">getAngularVelocity()</a> <a class="el" href="classPxRigidBody.html#a0aed51d5ddcf81b09a104ad7f0f30c05" title="Sets the linear velocity of the actor. ">setLinearVelocity()</a> </dd></dl>

</div>
</div>
<a id="ab152773926fe7b222d61e982c3cb6adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab152773926fe7b222d61e982c3cb6adf">&#9670;&nbsp;</a></span>setCMassLocalPose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setCMassLocalPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pose of the center of mass relative to the actor. </p>
<dl class="section note"><dt>Note</dt><dd>Changing this transform will not move the actor in the world!</dd>
<dd>
Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
<p><b>Default:</b> the identity transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Mass frame offset transform relative to the actor frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#aafdbdab1865112b15201aeabb23877b4" title="Retrieves the center of mass pose relative to the actor frame. ">getCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div>
<a id="ae1cf856d4059ff6b422b2c58f91d242f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cf856d4059ff6b422b2c58f91d242f">&#9670;&nbsp;</a></span>setForceAndTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setForceAndTorque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a6e707aa50e1612a2603643ee2df85f1a">PxForceMode::eFORCE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the impulsive force and torque defined in the global coordinate frame to the actor. </p>
<p><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> determines if the cleared torque is to be conventional or impulsive.</p>
<dl class="section note"><dt>Note</dt><dd>The force modes <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545aa3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time ">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#aadaaafefe0478d829b816154c676e545a9f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity change...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#acb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor. ">addTorque</a> </dd></dl>

</div>
</div>
<a id="ac81d09f36de3f2d1984709b559bb74ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81d09f36de3f2d1984709b559bb74ff">&#9670;&nbsp;</a></span>setLinearDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setLinearDamping </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>linDamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the linear damping coefficient. </p>
<p>Zero represents no damping. The damping coefficient must be nonnegative.</p>
<p><b>Default:</b> 0.0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linDamp</td><td>Linear damping coefficient. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#ad7fb785dde2e8e0954db807c7ec69a26" title="Retrieves the linear damping coefficient. ">getLinearDamping()</a> <a class="el" href="classPxRigidBody.html#adb8f357ce212cdf05250237073278d0c" title="Sets the angular damping coefficient. ">setAngularDamping()</a> </dd></dl>

</div>
</div>
<a id="a0aed51d5ddcf81b09a104ad7f0f30c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aed51d5ddcf81b09a104ad7f0f30c05">&#9670;&nbsp;</a></span>setLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setLinearVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>linVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the linear velocity of the actor. </p>
<p>Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.</p>
<p><b>Default:</b> (0.0, 0.0, 0.0)</p>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, the autowake parameter is true (default) or the new velocity is non-zero</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if <a class="el" href="structPxActorFlag.html#a1bc4c717e79cd547bdbe09a179ee9f1da0838a5b8c88cebfa5d53904bb3b97411" title="Disables simulation for the actor. ">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linVel</td><td>New linear velocity of actor. <b>Range:</b> velocity vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Whether to wake the object up if it is asleep and the velocity is non-zero. If true and the current wake counter value is smaller than <a class="el" href="classPxSceneDesc.html#a79e2c9c06f711272a48d7f07451117b7" title="The wake counter reset value. ">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a04bab22deecb716e2cdd7a64b5cfaee7" title="Retrieves the linear velocity of an actor. ">getLinearVelocity()</a> <a class="el" href="classPxRigidBody.html#ad49850630db14af26e019d2550ecfd27" title="Sets the angular velocity of the actor. ">setAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="a8a697a7a4b9bdd2c83a68e84b9bc3a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a697a7a4b9bdd2c83a68e84b9bc3a35">&#9670;&nbsp;</a></span>setMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMass </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>mass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mass of a dynamic actor. </p>
<p>The mass must be non-negative.</p>
<p><a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor. ">setMass()</a> does not update the inertial properties of the body, to change the inertia tensor use <a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates. ">setMassSpaceInertiaTensor()</a> or the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#a769be90cdb138897ce426aa04ac0a1e7" title="Computation of mass properties for a rigid body actor. ">PxRigidBodyExt::updateMassAndInertia()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 is interpreted as infinite mass. </dd>
<dd>
Values of 0 are not permitted for instances of <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body ">PxArticulationLink</a> but are permitted for instances of <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK. ">PxRigidDynamic</a>.</dd></dl>
<p><b>Default:</b> 1.0</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>New mass value for the actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a2b1c475ca9cc6aebc168ac58256b7284" title="Retrieves the mass of the actor. ">getMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#a755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates. ">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div>
<a id="a755d0c8a8d1dd8b29e59d50a6dfda5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755d0c8a8d1dd8b29e59d50a6dfda5fd">&#9670;&nbsp;</a></span>setMassSpaceInertiaTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMassSpaceInertiaTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the inertia tensor, using a parameter specified in mass space coordinates. </p>
<p>Note that such matrices are diagonal &ndash; the passed vector is the diagonal.</p>
<p>If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to diagonalize it and set an appropriate mass space transform. See <a class="el" href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor. ">setCMassLocalPose()</a>.</p>
<p>The inertia tensor elements must be non-negative.</p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis. </dd>
<dd>
Values of 0 are not permitted for instances of <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body ">PxArticulationLink</a> but are permitted for instances of <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK. ">PxRigidDynamic</a>.</dd></dl>
<p><b>Default:</b> (1.0, 1.0, 1.0)</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>New mass space inertia tensor for the actor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>PxRigidBodyDesc.massSpaceInertia getMassSpaceInertia() <a class="el" href="classPxRigidBody.html#a8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor. ">setMass()</a> <a class="el" href="classPxRigidBody.html#ab152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor. ">setCMassLocalPose()</a> </dd></dl>

</div>
</div>
<a id="afdf8a649186d2b993b0e64d6228706db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf8a649186d2b993b0e64d6228706db">&#9670;&nbsp;</a></span>setMaxAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMaxAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>maxAngVel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets you set the maximum angular velocity permitted for this actor. </p>
<p>For various internal computations, very quickly rotating actors introduce error into the simulation, which leads to undesired results.</p>
<p>With this function, you can set the maximum angular velocity permitted for this rigid body. Higher angular velocities are clamped to this value.</p>
<p>Note: The angular velocity is clamped to the set value <em>before</em> the solver, which means that the limit may still be momentarily exceeded.</p>
<p><b>Default:</b> 100.0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxAngVel</td><td>Max allowable angular velocity for actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a8052320915132f7d7f72ede4543b64ad" title="Retrieves the maximum angular velocity permitted for this actor. ">getMaxAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="a1a3bbe100e644995742f80f19ea8f250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3bbe100e644995742f80f19ea8f250">&#9670;&nbsp;</a></span>setMaxContactImpulse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMaxContactImpulse </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>maxImpulse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxImpulse</td><td>the maximum contact impulse. <b>Range:</b> [0, PX_MAX_F32] <b>Default:</b> PX_MAX_F32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a2f9e9e7946ab265013229612aad4c3c7" title="Returns the maximum impulse that may be applied at a contact. ">getMaxContactImpulse</a> </dd></dl>

</div>
</div>
<a id="a261ce18fdc6cb81c0bfb46590db0867d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261ce18fdc6cb81c0bfb46590db0867d">&#9670;&nbsp;</a></span>setMaxDepenetrationVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMaxDepenetrationVelocity </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>biasClamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">biasClamp</td><td>The maximum velocity to de-penetrate by <b>Range:</b> (0, PX_MAX_F32]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a399c1bb619f89ad1df4400a03a242051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399c1bb619f89ad1df4400a03a242051">&#9670;&nbsp;</a></span>setMaxLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMaxLinearVelocity </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>maxLinVel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets you set the maximum linear velocity permitted for this actor. </p>
<p>With this function, you can set the maximum linear velocity permitted for this rigid body. Higher angular velocities are clamped to this value.</p>
<p>Note: The angular velocity is clamped to the set value <em>before</em> the solver, which means that the limit may still be momentarily exceeded.</p>
<p><b>Default:</b> PX_MAX_F32</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLinVel</td><td>Max allowable linear velocity for actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxRigidBody.html#a8052320915132f7d7f72ede4543b64ad" title="Retrieves the maximum angular velocity permitted for this actor. ">getMaxAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="ac6f4fe582726801cb09c2381de0c144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f4fe582726801cb09c2381de0c144d">&#9670;&nbsp;</a></span>setMinCCDAdvanceCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMinCCDAdvanceCoefficient </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>advanceCoefficient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the CCD minimum advance coefficient. </p>
<p>The CCD minimum advance coefficient is a value in the range [0, 1] that is used to control the minimum amount of time a body is integrated when it has a CCD contact. The actual minimum amount of time that is integrated depends on various properties, including the relative speed and collision shapes of the bodies involved in the contact. From these properties, a numeric value is calculated that determines the maximum distance (and therefore maximum time) which these bodies could be integrated forwards that would ensure that these bodies did not pass through each-other. This value is then scaled by CCD minimum advance coefficient to determine the amount of time that will be consumed in the CCD pass.</p>
<p><b>Things to consider:</b> A large value (approaching 1) ensures that the objects will always advance some time. However, larger values increase the chances of objects gently drifting through each-other in scenes which the constraint solver can't converge, e.g. scenes where an object is being dragged through a wall with a constraint. A value of 0 ensures that the pair of objects stop at the exact time-of-impact and will not gently drift through each-other. However, with very small/thin objects initially in contact, this can lead to a large amount of time being dropped and increases the chances of jamming. Jamming occurs when the an object is persistently in contact with an object such that the time-of-impact is 0, which results in no time being advanced for those objects in that CCD pass.</p>
<p>The chances of jamming can be reduced by increasing the number of CCD mass </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classPxSceneDesc.html#a65aa4ceefbbd6aebd75ea879d7c385f9" title="Maximum number of CCD passes. ">PxSceneDesc.ccdMaxPasses</a>. However, increasing this number increases the CCD overhead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">advanceCoefficient</td><td>The CCD min advance coefficient. <b>Range:</b> [0, 1] <b>Default:</b> 0.15 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b23b890404b1010bf0b67a225bd22e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b23b890404b1010bf0b67a225bd22e7">&#9670;&nbsp;</a></span>setRigidBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setRigidBodyFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxRigidBodyFlag.html#a5fd4878ae66a98c030a9d976e8ba8596">PxRigidBodyFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raises or clears a particular rigid body flag. </p>
<p>See the list of flags <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a></p>
<p><b>Default:</b> no flags are set</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects. ">PxRigidBody</a> flag to raise(set) or clear. See <a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new boolean value for the flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structPxRigidBodyFlag.html" title="Collection of flags describing the behavior of a rigid body. ">PxRigidBodyFlag</a> <a class="el" href="classPxRigidBody.html#a2ef3c66318db72f2dd2c1b0d20513f18" title="Reads the PxRigidBody flags. ">getRigidBodyFlags()</a> </dd></dl>

</div>
</div>
<a id="a9e6f3afd71605e037a5de47955d941e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6f3afd71605e037a5de47955d941e0">&#9670;&nbsp;</a></span>setRigidBodyFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setRigidBodyFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#ga2ab6803c803ae6372791ff060068c6a1">PxRigidBodyFlags</a>&#160;</td>
          <td class="paramname"><em>inFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidBody_8h_source.html">PxRigidBody.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPxRigidBody.html">PxRigidBody</a></li>
    <li class="footer">Copyright &copy; 2008-2019 NVIDIA Corporation, 2788 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a></li>
  </ul>
</div>
</body>
</html>
